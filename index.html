<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Urdu Learning Studio</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            overflow: hidden;
        }

        .header {
            background: #1a1a1a;
            color: white;
            padding: 30px;
            text-align: center;
            position: relative;
        }
        
        .auth-section {
            position: absolute;
            top: 20px;
            right: 30px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .auth-button {
            background: #4285f4;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .auth-button:hover {
            background: #3367d6;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        }
        
        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid white;
        }
        
        .sign-out-btn {
            background: #dc3545;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        .sign-out-btn:hover {
            background: #c82333;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-family: 'Noto Nastaliq Urdu', serif;
        }

        .header p {
            opacity: 0.8;
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            min-height: 600px;
        }

        .story-panel {
            flex: 1;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-right: 20px;
            display: flex;
            flex-direction: column;
            height: 80vh;
        }

        .story-selector {
            margin-bottom: 20px;
        }

        .story-selector select {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .text-reading-area {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f9fafb;
            border-radius: 0 0 12px 12px;
            /* MOBILE FIX: Prevent horizontal overflow */
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
            overflow-x: hidden;
        }

        .urdu-text {
            font-family: 'Noto Nastaliq Urdu', serif;
            font-size: 18px;
            line-height: 2.2;
            text-align: right;
            direction: rtl;
            background: transparent;
            padding: 0;
            border: none;
            min-height: 300px;
            height: 100%;
            /* MOBILE FIX: Proper text wrapping */
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: pre-wrap;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }

        .urdu-word {
            padding: 2px 4px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .urdu-word:hover {
            background: #fef3c7;
        }

        .urdu-word.active {
            background: #d1fae5;
            box-shadow: 0 0 0 2px #10b981;
        }

        .urdu-word.selected {
            background: linear-gradient(120deg, #dbeafe 0%, #bfdbfe 100%);
            text-decoration: underline;
            text-decoration-color: #3b82f6;
            text-decoration-thickness: 2px;
        }

        .sidebar {
            background: #f9fafb;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .translation-box {
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            min-height: 150px;
        }

        .translation-box h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #1f2937;
        }

        .word-display {
            font-family: 'Noto Nastaliq Urdu', serif;
            font-size: 28px;
            color: #1f2937;
            margin-bottom: 10px;
            text-align: center;
        }

        .translation-text {
            font-size: 18px;
            color: #374151;
            text-align: center;
            margin: 10px 0;
        }

        .save-button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 15px;
            transition: transform 0.2s;
        }

        .save-button:hover {
            transform: translateY(-2px);
        }

        .vocabulary-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            padding: 20px;
            border-radius: 12px;
            border: 1px solid #e5e7eb;
            overflow: hidden;
        }

        .vocabulary-box h3 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #1f2937;
        }

        .vocab-list {
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .vocab-item {
            background: #f9fafb;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e5e7eb;
        }

        .vocab-word {
            font-family: 'Noto Nastaliq Urdu', serif;
            font-size: 20px;
            color: #1f2937;
        }

        .vocab-translation {
            font-size: 14px;
            color: #6b7280;
        }

        .vocab-actions {
            margin-top: 8px;
            display: flex;
            gap: 8px;
        }

        .jump-button {
            padding: 4px 8px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .jump-button:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .urdu-word.saved {
            border-bottom: 2px solid #d1d5db;
            border-bottom-style: dotted;
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 180px;
            background-color: #1f2937;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            top: -45px;
            left: 50%;
            margin-left: -90px;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 11px;
            white-space: nowrap;
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: #1f2937 transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        @keyframes flash {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); background: #fbbf24; }
            100% { transform: scale(1); }
        }

        .empty-vocab {
            text-align: center;
            color: #9ca3af;
            padding: 40px;
            font-style: italic;
        }

        /* Mobile Translation Bar */
        .mobile-translation-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-top: 1px solid #e5e7eb;
            padding: 15px 20px;
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease;
            display: none;
            max-height: 40vh; /* Prevent taking up too much screen */
            overflow-y: auto; /* Allow scrolling if needed */
        }

        .mobile-translation-bar.show {
            transform: translateY(0);
        }

        .mobile-translation-content {
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 100%;
        }

        .mobile-text-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 10px;
            min-height: 44px; /* Ensure touch-friendly height */
        }

        .mobile-word {
            font-family: 'Noto Nastaliq Urdu', serif;
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
            flex-shrink: 0;
            max-width: 40%;
            word-wrap: break-word;
            line-height: 1.4;
        }

        .mobile-translation {
            font-size: 16px;
            color: #4b5563;
            flex-grow: 1;
            text-align: left;
            line-height: 1.4;
            word-wrap: break-word;
            max-width: 60%;
        }

        .mobile-save {
            background: #10b981;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            min-height: 44px; /* Touch-friendly height */
            font-weight: 600;
        }

        .mobile-save:hover {
            background: #059669;
        }


        .mobile-vocab-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 2000;
            display: none;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .mobile-vocab-modal.show {
            display: flex;
        }

        .mobile-vocab-content {
            background: white;
            border-radius: 12px;
            width: 100%;
            max-width: 400px;
            max-height: 80vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .mobile-vocab-header {
            padding: 20px 20px 0 20px;
            border-bottom: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .vocab-header-controls {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .vocab-tabs {
            display: flex;
            border-bottom: 2px solid #f3f4f6;
            margin: 0 20px;
        }

        .filter-status-bar {
            background: #eff6ff;
            border: 1px solid #bfdbfe;
            border-radius: 8px;
            padding: 8px 12px;
            margin: 15px 20px 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 13px;
        }

        .filter-status-text {
            color: #1e40af;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .clear-filters-btn {
            background: #dc2626;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            font-weight: 500;
        }

        .clear-filters-btn:hover {
            background: #b91c1c;
        }

        .vocab-tab {
            background: none;
            border: none;
            padding: 12px 20px;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s ease;
        }

        .vocab-tab.active {
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }

        .vocab-tab:hover {
            color: #374151;
        }

        .vocab-tab-content {
            display: none;
        }

        .vocab-tab-content.active {
            display: block;
        }

        .vocab-filter-toggle {
            background: #f3f4f6;
            border: none;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            color: #6b7280;
        }

        .vocab-filter-toggle.active {
            background: #3b82f6;
            color: white;
        }

        .difficulty-dot {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            margin-right: 10px;
            border: 2px solid transparent;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }

        .difficulty-dot-large {
            width: 20px;
            height: 20px;
            margin-right: 12px;
        }

        .difficulty-dot:hover {
            transform: scale(1.2);
            border-color: #374151;
        }

        .difficulty-easy {
            background: #10b981;
        }

        .difficulty-medium {
            background: #f59e0b;
        }

        .difficulty-hard {
            background: #ef4444;
        }

        .filter-section {
            padding: 20px;
            border-bottom: 1px solid #f3f4f6;
        }

        .filter-section:last-child {
            border-bottom: none;
        }

        .filter-label {
            font-size: 14px;
            font-weight: 600;
            color: #374151;
            margin-bottom: 12px;
        }

        .filter-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: #f9fafb;
            border: 1px solid #e5e7eb;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 13px;
            cursor: pointer;
            color: #374151;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s ease;
        }

        .filter-btn.active {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .filter-btn:hover {
            background: #f3f4f6;
            border-color: #d1d5db;
        }

        .filter-btn.active:hover {
            background: #2563eb;
        }

        .vocab-item-left {
            display: flex;
            align-items: center;
            flex-grow: 1;
        }

        .vocab-item-text {
            flex-grow: 1;
        }

        .vocab-bin-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 8px;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .vocab-bin-btn:hover {
            background: #dc2626;
        }

        .mobile-vocab-title {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
        }

        .mobile-vocab-close {
            background: none;
            border: none;
            font-size: 28px;
            color: #6b7280;
            cursor: pointer;
            padding: 8px;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            transition: background-color 0.2s;
        }
        
        .mobile-vocab-close:hover {
            background-color: #f3f4f6;
            color: #374151;
        }
        
        /* Novel progress bar styles */
        .novel-progress {
            display: flex;
            align-items: center;
            font-size: 14px;
            color: #374151;
        }
        
        .progress-text {
            margin-right: 8px;
            font-weight: 500;
        }
        
        .progress-bar {
            width: 100px;
            height: 8px;
            background-color: #e5e7eb;
            border-radius: 4px;
            overflow: hidden;
            margin-right: 8px;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #22c55e);
            border-radius: 4px;
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .progress-percent {
            font-size: 12px;
            font-weight: 600;
            color: #10b981;
        }

        .mobile-vocab-list {
            padding: 15px 20px;
            overflow-y: auto;
            flex-grow: 1;
            max-height: calc(80vh - 200px);
            -webkit-overflow-scrolling: touch;
        }

        .mobile-vocab-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #f3f4f6;
        }

        .mobile-vocab-item:last-child {
            border-bottom: none;
        }

        .mobile-vocab-word {
            font-family: 'Noto Nastaliq Urdu', serif;
            font-size: 16px;
            font-weight: bold;
            color: #1f2937;
        }

        .mobile-vocab-translation {
            font-size: 14px;
            color: #6b7280;
            margin-top: 2px;
        }

        .mobile-vocab-actions {
            display: flex;
            gap: 8px;
        }

        .mobile-vocab-clear {
            background: #ef4444;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 0 0 12px 12px;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
        }

        @media (min-width: 768px) {
            .mobile-translation-bar {
                display: none !important;
            }
        }

        /* Top Vocabulary Button */
        .vocab-btn {
            background: #6366f1;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
            transition: background 0.2s ease;
        }

        .vocab-btn:hover {
            background: #4f46e5;
        }

        .vocab-badge {
            background: #ef4444;
            color: white;
            border-radius: 50%;
            width: 18px;
            height: 18px;
            font-size: 11px;
            font-weight: bold;
            display: none;
            align-items: center;
            justify-content: center;
            min-width: 18px;
        }

        @media (max-width: 767px) {
            .sidebar {
                display: none;
            }
            .mobile-translation-bar {
                display: block;
            }
            .story-panel {
                height: calc(100vh - 140px);
                margin-right: 0;
                margin-bottom: 100px;
            }
            .top-controls-bar {
                flex-direction: column;
                gap: 10px;
                padding: 10px 15px;
            }
            .controls-left {
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }
            .controls-right {
                width: 100%;
                justify-content: center;
            }
            .urdu-text {
                font-size: 16px;
                line-height: 2.0;
            }
        }


        .clear-button {
            padding: 10px;
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-top: 10px;
            font-weight: 600;
        }

        .top-controls-bar {
            position: sticky;
            top: 0;
            background: white;
            padding: 15px 20px;
            border-bottom: 2px solid #e5e7eb;
            border-radius: 12px 12px 0 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            min-height: 60px;
        }

        .controls-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .controls-right {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .page-navigation {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .page-button {
            padding: 8px 12px;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .page-button:hover {
            background: #2563eb;
        }

        .page-button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .page-info {
            font-size: 14px;
            color: #6b7280;
            min-width: 80px;
            text-align: center;
        }

        .translation-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toggle-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .toggle-button:hover {
            transform: translateY(-1px);
        }

        .toggle-button.translating {
            background: #6b7280;
            cursor: not-allowed;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            
            .story-panel {
                border-right: none;
                border-bottom: 1px solid #e5e7eb;
                padding: 15px 10px;
                /* MOBILE FIX: Better mobile layout */
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
            }
            
            .story-controls {
                flex-direction: column;
                gap: 15px;
                align-items: stretch;
            }
            
            .page-navigation {
                justify-content: center;
                flex-wrap: wrap;
                gap: 8px;
                /* MOBILE FIX: Ensure navigation buttons fit properly */
                padding: 10px 5px;
                margin: 0;
                width: 100%;
                box-sizing: border-box;
            }
            
            .translation-toggle {
                justify-content: center;
            }
            
            .toggle-button {
                padding: 12px 20px;
                font-size: 16px;
                white-space: nowrap;
                min-width: 160px;
            }
            
            .page-button {
                padding: 10px 16px;
                font-size: 16px;
                min-width: 80px;
            }
            
            .page-info {
                min-width: 100px;
                font-size: 16px;
            }
            
            .container {
                margin: 5px;
                border-radius: 15px;
                /* MOBILE FIX: Ensure full width usage */
                width: calc(100% - 10px);
                max-width: 100%;
                box-sizing: border-box;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .text-reading-area {
                /* MOBILE FIX: Better text area constraints */
                padding: 8px;
                margin: 0;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow-x: hidden;
                overflow-y: auto;
            }
            
            .urdu-text {
                font-size: 16px;
                line-height: 2.0;
                padding: 5px;
                /* MOBILE FIX: Ensure proper wrapping on mobile */
                word-wrap: break-word;
                overflow-wrap: break-word;
                white-space: pre-wrap;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                /* MOBILE FIX: Prevent text from expanding beyond container */
                hyphens: auto;
                -webkit-hyphens: auto;
                -ms-hyphens: auto;
                /* MOBILE FIX: Ensure RTL text doesn't overflow */
                margin: 0;
                border: none;
                outline: none;
            }
            
            /* MOBILE FIX: Better page navigation visibility - removed duplicate */
            
            .page-button {
                min-width: 90px;
                padding: 12px 16px;
                font-size: 15px;
                white-space: nowrap;
            }
            
            .page-info {
                min-width: 110px;
                font-size: 15px;
                text-align: center;
                padding: 0 10px;
            }
            
            .sidebar {
                padding: 20px;
            }
        }
        
        /* COMPREHENSIVE MOBILE FIX: Complete mobile layout redesign */
        @media (max-width: 480px) {
            * {
                box-sizing: border-box;
            }
            
            body {
                margin: 0;
                padding: 0;
                overflow-x: hidden;
            }
            
            .container {
                margin: 0;
                padding: 0;
                width: 100vw;
                max-width: 100vw;
                overflow-x: hidden;
            }
            
            .header {
                padding: 40px 8px 8px 8px;
                margin: 0;
                width: 100%;
                position: relative;
            }
            
            .auth-section {
                position: absolute;
                top: 4px;
                left: 50%;
                transform: translateX(-50%);
                z-index: 10;
                width: auto;
            }
            
            .auth-button {
                padding: 4px 8px;
                font-size: 11px;
                border-radius: 4px;
                white-space: nowrap;
            }
            
            .header h1 {
                font-size: 1.6rem;
                margin: 0 0 8px 0;
            }
            
            .header p {
                font-size: 0.9rem;
                margin: 0;
            }
            
            .main-content {
                grid-template-columns: 1fr;
                margin: 0;
                padding: 0;
            }
            
            .story-panel {
                margin: 0;
                padding: 0;
                width: 100vw;
                max-width: 100vw;
                height: calc(100vh - 140px);
                border-radius: 0;
                overflow: hidden;
            }
            
            .top-controls-bar {
                padding: 6px 4px;
                margin: 0;
                width: 100%;
                flex-direction: column;
                gap: 4px;
            }
            
            .controls-left, .controls-right {
                width: 100%;
                margin: 0;
                padding: 0 2px;
            }
            
            .controls-left select {
                width: 100%;
                font-size: 13px;
                padding: 6px;
                margin-bottom: 4px;
            }
            
            .page-navigation {
                width: 100%;
                display: flex;
                justify-content: space-around;
                align-items: center;
                gap: 2px;
                padding: 2px;
                margin: 0;
            }
            
            .page-button {
                flex: 0 0 auto;
                min-width: 60px;
                max-width: 80px;
                padding: 4px 6px;
                font-size: 11px;
                border-radius: 3px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            
            .page-info {
                flex: 1;
                font-size: 11px;
                text-align: center;
                min-width: 60px;
                padding: 0 2px;
                white-space: nowrap;
            }
            
            .toggle-button {
                width: 100%;
                max-width: none;
                padding: 6px 8px;
                font-size: 12px;
                margin: 2px 0;
            }
            
            .text-reading-area {
                padding: 4px;
                margin: 0;
                width: 100%;
                overflow-x: hidden;
                overflow-y: auto;
            }
            
            .urdu-text {
                font-size: 14px;
                line-height: 1.8;
                padding: 4px;
                margin: 0;
                width: 100%;
                word-wrap: break-word;
                overflow-wrap: break-word;
                white-space: pre-wrap;
                direction: rtl;
                text-align: right;
            }
            
            .urdu-word {
                padding: 1px 2px;
            }
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header class="header">
            <div class="auth-section" id="authSection">
                <!-- Auth UI will be dynamically updated -->
            </div>
            <h1>ÿßÿ±ÿØŸà Learning Studio</h1>
            <p>Click words for instant translation</p>
        </header>

        <div class="main-content">
            <div class="story-panel">
                <div class="top-controls-bar">
                    <div class="controls-left">
                        <select id="storySelect" onchange="loadStory(this.value)">
                            <option value="0">1. The Little Bird ‚Ä¢ ⁄Ü⁄æŸàŸπÿß Ÿæÿ±ŸÜÿØ€Å</option>
                            <option value="1">2. The Garden ‚Ä¢ ÿ®ÿßÿ∫</option>
                            <option value="2">3. The Friend ‚Ä¢ ÿØŸàÿ≥ÿ™</option>
                            <option value="3">4. The Cat ‚Ä¢ ÿ®ŸÑ€å</option>
                        </select>
                        
                        <div id="novelProgress" class="novel-progress" style="display: none; margin-left: 15px;">
                            <span class="progress-text">üìö Novel: </span>
                            <div class="progress-bar">
                                <div class="progress-fill" id="progressFill"></div>
                            </div>
                            <span class="progress-percent" id="progressPercent">0%</span>
                        </div>
                        
                        <div class="page-navigation">
                            <button class="page-button" id="prevPageBtn" onclick="previousPage()" disabled>‚Üê Previous</button>
                            <span class="page-info" id="pageInfo">Page 1 of 1</span>
                            <button class="page-button" id="nextPageBtn" onclick="nextPage()" disabled>Next ‚Üí</button>
                        </div>
                    </div>
                    
                    <div class="controls-right">
                        <button class="toggle-button" id="translateToggle" onclick="togglePageTranslation()">
                            Translate to English
                        </button>
                        
                        <button class="vocab-btn" onclick="showMobileVocab()">
                            üìö <span id="topVocabBadge" class="vocab-badge">0</span>
                        </button>
                    </div>
                </div>

                <div class="text-reading-area">
                    <div class="urdu-text" id="urduText">
                        Loading...
                    </div>
                </div>
            </div>

            <div class="sidebar">
                <div class="translation-box">
                    <h3>Translation</h3>
                    <div id="translationContent">
                        Click any Urdu word to see its translation
                    </div>
                </div>

                <div class="vocabulary-box">
                    <h3>Saved Vocabulary</h3>
                    <div class="vocab-list" id="vocabList">
                        <div class="empty-vocab">No saved words yet</div>
                    </div>
                    <button class="clear-button" onclick="clearVocabulary()" style="display: none;" id="clearButton">
                        Clear All
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile Translation Bar -->
    <div id="mobileTranslationBar" class="mobile-translation-bar">
        <div class="mobile-translation-content">
            <div class="mobile-text-row">
                <div class="mobile-word" id="mobileWord"></div>
                <div class="mobile-translation" id="mobileTranslation"></div>
            </div>
            <button class="mobile-save" id="mobileSave" onclick="saveMobileWord()">Save</button>
        </div>
    </div>


    <!-- Mobile Vocabulary Modal -->
    <div id="mobileVocabModal" class="mobile-vocab-modal" onclick="closeMobileVocabOnOverlay(event)">
        <div class="mobile-vocab-content" onclick="event.stopPropagation()">
            <div class="mobile-vocab-header">
                <div class="mobile-vocab-title">Saved Vocabulary</div>
                <div class="vocab-header-controls">
                    <button class="vocab-bin-btn" onclick="confirmClearVocab()" title="Clear All Vocabulary">üóëÔ∏è</button>
                    <button class="mobile-vocab-close" onclick="hideMobileVocab()" title="Close (changes saved automatically)">√ó</button>
                </div>
            </div>
            
            <div class="vocab-tabs">
                <button class="vocab-tab active" id="browseTab" onclick="switchVocabTab('browse')">üìö Browse</button>
                <button class="vocab-tab" id="filterTab" onclick="switchVocabTab('filter')">üîç Filter</button>
            </div>
            
            <div class="vocab-tab-content active" id="browseContent">
                <div class="filter-status-bar" id="filterStatusBar" style="display: none;">
                    <div class="filter-status-text" id="filterStatusText"></div>
                    <button class="clear-filters-btn" id="clearFiltersBtn" onclick="clearAllFilters()">Clear</button>
                </div>
                <div class="mobile-vocab-list" id="mobileVocabList">
                    <div style="text-align: center; color: #6b7280; padding: 20px;">No saved words yet</div>
                </div>
            </div>
            
            <div class="vocab-tab-content" id="filterContent">
                <div class="filter-section">
                    <div class="filter-label">Story Scope</div>
                    <div class="filter-group">
                        <button class="filter-btn active" id="storyCurrentBtn" onclick="setStoryFilter('current')">This Story</button>
                        <button class="filter-btn" id="storyAllBtn" onclick="setStoryFilter('all')">All Stories</button>
                    </div>
                </div>
                
                <div class="filter-section">
                    <div class="filter-label">Difficulty Level</div>
                    <div class="filter-group">
                        <button class="filter-btn active" id="diffAllBtn" onclick="setDifficultyFilter('all')">All Levels</button>
                        <button class="filter-btn" id="diffEasyBtn" onclick="setDifficultyFilter('easy')">
                            <span class="difficulty-dot difficulty-easy"></span>Easy
                        </button>
                        <button class="filter-btn" id="diffMediumBtn" onclick="setDifficultyFilter('medium')">
                            <span class="difficulty-dot difficulty-medium"></span>Medium
                        </button>
                        <button class="filter-btn" id="diffHardBtn" onclick="setDifficultyFilter('hard')">
                            <span class="difficulty-dot difficulty-hard"></span>Hard
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Supabase JavaScript SDK -->
    <script src="https://unpkg.com/@supabase/supabase-js@2"></script>
    
    <script>
        // Supabase configuration
        const supabaseUrl = 'https://uymviydoewqtwicrklqk.supabase.co'
        const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV5bXZpeWRvZXdxdHdpY3JrbHFrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTM2NTA3MTgsImV4cCI6MjA2OTIyNjcxOH0.OdkfTjn-c6aXBTvqedUg9gJg-ShD1CBWc6Gnfpe-96U'
        let supabaseClient = null
        
        // Authentication state
        let currentUser = null
        
        // Initialize Supabase client safely
        function initSupabase() {
            if (window.supabase) {
                supabaseClient = window.supabase.createClient(supabaseUrl, supabaseAnonKey)
                return true
            }
            return false
        }
        
        // Initialize auth UI immediately
        function initAuthUI() {
            if (initSupabase()) {
                updateAuthUI()
            } else {
                // Try again in a moment if Supabase hasn't loaded yet
                setTimeout(() => {
                    if (initSupabase()) {
                        updateAuthUI()
                    }
                }, 100)
            }
        }
        
        // Configuration - API calls now go through Vercel function
        // No API key needed on client side
        
        // State
        let vocabulary = [];
        let translationCache = new Map();
        let selectedWords = [];
        let isSelecting = false;
        let selectionStart = -1;
        let currentPage = 0;
        let pagesPerStory = [];
        let isTranslated = false;
        let translatedPages = new Map();
        let bbcArticleLoaded = false;
        let currentPopupWord = '';
        let currentPopupTranslation = '';
        let popupTimeout = null;

        // Stories - split into pages (chunks)
        let stories = [
            "ÿß€å⁄© ⁄Ü⁄æŸàŸπÿß Ÿæÿ±ŸÜÿØ€Å ÿØÿ±ÿÆÿ™ Ÿæÿ± ÿ®€åŸπ⁄æÿß ÿ™⁄æÿß€î Ÿà€Å ÿ®€Åÿ™ ÿÆŸàÿ¥ ÿ™⁄æÿß€î ÿµÿ®ÿ≠ ⁄©ÿß ŸàŸÇÿ™ ÿ™⁄æÿß ÿßŸàÿ± ÿ≥Ÿàÿ±ÿ¨ ŸÜ⁄©ŸÑ ÿ±€Åÿß ÿ™⁄æÿß€î Ÿæÿ±ŸÜÿØ€Å ÿÆŸàÿ®ÿµŸàÿ±ÿ™ ⁄ØÿßŸÜÿß ⁄Øÿß ÿ±€Åÿß ÿ™⁄æÿß€î ÿßÿ≥ ⁄©€å ÿ¢Ÿàÿßÿ≤ ŸÖ€å⁄∫ ÿÆŸàÿ¥€å ÿ™⁄æ€å€î ÿ≥ÿ® ŸÑŸà⁄Ø ÿßÿ≥ ⁄©ÿß ⁄ØÿßŸÜÿß ÿ≥ŸÜ ÿ±€Å€í ÿ™⁄æ€í€î",
            "ŸÖ€åÿ±€í ⁄Ø⁄æÿ± ⁄©€í Ÿæÿßÿ≥ ÿß€å⁄© ÿÆŸàÿ®ÿµŸàÿ±ÿ™ ÿ®ÿßÿ∫ €Å€í€î ÿßÿ≥ ŸÖ€å⁄∫ ⁄©ÿ¶€å ÿ∑ÿ±ÿ≠ ⁄©€í ÿ±ŸÜ⁄Ø ÿ®ÿ±ŸÜ⁄Ø€í Ÿæ⁄æŸàŸÑ €Å€å⁄∫€î ⁄ØŸÑÿßÿ® ⁄©€í Ÿæ⁄æŸàŸÑ ÿ≥ÿ±ÿÆ ÿßŸàÿ± ⁄ØŸÑÿßÿ®€å €Å€å⁄∫€î ⁄ÜŸÖ€åŸÑ€å ⁄©€í Ÿæ⁄æŸàŸÑ ÿ≥ŸÅ€åÿØ ÿßŸàÿ± ÿÆŸàÿ¥ÿ®ŸàÿØÿßÿ± €Å€å⁄∫€î €Åÿ± ÿµÿ®ÿ≠ ŸÖ€å⁄∫ ÿ®ÿßÿ∫ ŸÖ€å⁄∫ ÿ¨ÿßÿ™ÿß €ÅŸà⁄∫€î",
            "ÿßÿ≠ŸÖÿØ ŸÖ€åÿ±ÿß ÿ®€Åÿ™ÿ±€åŸÜ ÿØŸàÿ≥ÿ™ €Å€í€î Ÿà€Å ÿ®€Åÿ™ ÿß⁄Ü⁄æÿß ÿßŸàÿ± ŸÖ€Åÿ±ÿ®ÿßŸÜ ŸÑ⁄ë⁄©ÿß €Å€í€î €ÅŸÖ ÿ±Ÿàÿ≤ÿßŸÜ€Å ÿßÿ≥⁄©ŸàŸÑ ÿ¨ÿßÿ™€í €Å€å⁄∫€î €ÅŸÖ ÿ≥ÿßÿ™⁄æ ⁄©⁄æ€åŸÑÿ™€í €Å€å⁄∫ ÿßŸàÿ± Ÿæ⁄ë⁄æÿ™€í €Å€å⁄∫€î ÿßÿ≠ŸÖÿØ €ÅŸÖ€åÿ¥€Å ŸÖ€åÿ±€å ŸÖÿØÿØ ⁄©ÿ±ÿ™ÿß €Å€í€î ŸÖ€å⁄∫ ÿßÿ≥ ⁄©ÿß ÿ®€Åÿ™ ÿ¥⁄©ÿ±€å€Å ÿßÿØÿß ⁄©ÿ±ÿ™ÿß €ÅŸà⁄∫€î",
            "ÿ®ŸÑ€å ⁄Ü⁄æÿ™ Ÿæÿ± ÿ≥Ÿà ÿ±€Å€å ÿ™⁄æ€å€î ÿß⁄ÜÿßŸÜ⁄© ÿ®ÿßÿ±ÿ¥ ÿ¥ÿ±Ÿàÿπ €ÅŸàÿ¶€å€î ÿ®ŸÑ€å ÿ¨ŸÑÿØ€å ÿ≥€í ⁄Ø⁄æÿ± ⁄©€í ÿßŸÜÿØÿ± ÿ®⁄æÿß⁄Ø€å€î Ÿà€Å ÿßŸæŸÜ€í ÿ®⁄ÜŸà⁄∫ ⁄©€í Ÿæÿßÿ≥ ⁄Øÿ¶€å€î ÿ™ŸÖÿßŸÖ ÿ®ŸÑ€åÿß⁄∫ ŸÖÿ≠ŸÅŸàÿ∏ ÿ™⁄æ€å⁄∫€î ÿ®ÿßÿ±ÿ¥ ÿ±⁄© ⁄Øÿ¶€å ÿßŸàÿ± ÿØ⁄æŸàŸæ ŸÜ⁄©ŸÑ ÿ¢ÿ¶€å€î"
        ];
        
        // Novel episodes metadata
        const novelData = {
            title: "Mann Kay Muhallay Mein",
            author: "Shakeel Ahmed Chohan", 
            totalEpisodes: 24,
            baseUrl: "https://www.urdupoint.com/books/detail/mann-kay-muhallay-mein/",
            episodes: [
                { id: 7972, title: "Episode 1" },
                { id: 7973, title: "Episode 2" },
                { id: 7974, title: "Episode 3" },
                { id: 7980, title: "Episode 4" },
                { id: 7983, title: "Episode 5" },
                // Add more episodes as discovered
            ]
        };
        
        // Novel progress tracking (stored in localStorage)
        let novelProgress = JSON.parse(localStorage.getItem('novelProgress') || '{"currentEpisode": 1, "episodesRead": [], "bookmarks": {}}');

        // Create optimized English headlines for BBC articles
        function createOptimizedHeadline(urduTitle) {
            // Map common Urdu article patterns to concise English headlines
            const patterns = [
                { urdu: /ÿß€åÿ¥€åÿß ⁄©Ÿæ|⁄©ÿ±⁄©Ÿπ/, english: "BBC Asia Cup Cricket Tournament" },
                { urdu: /ÿ≥Ÿàÿ¥ŸÑ ŸÖ€å⁄à€åÿß.*Ÿæÿßÿ®ŸÜÿØ€å|ÿ®⁄ÜŸà⁄∫.*ÿ≥Ÿàÿ¥ŸÑ/, english: "BBC Social Media Age Restrictions" },
                { urdu: /⁄©ÿ±ŸÜÿ≥€å|⁄àÿßŸÑÿ±|ÿ¢ÿ¶€å ÿß€åÿ≥ ÿ¢ÿ¶€å/, english: "BBC Currency & ISI Investigation" },
                { urdu: /Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ.*ÿßŸÜ⁄à€åÿß/, english: "BBC Pakistan-India Relations" },
                { urdu: /Ÿπ⁄© Ÿπÿß⁄©|ŸÅ€åÿ≥ ÿ®⁄©|ÿßŸÜÿ≥Ÿπÿß⁄Øÿ±ÿßŸÖ/, english: "BBC Social Media Platforms" },
                { urdu: /⁄©Ÿæ 2025/, english: "BBC Asia Cup 2025" }
            ];
            
            // Check patterns and return optimized headline
            for (const pattern of patterns) {
                if (pattern.urdu.test(urduTitle)) {
                    return pattern.english;
                }
            }
            
            // Fallback: create generic headline from first few words
            const words = urduTitle.split(/\s+/).slice(0, 3);
            return "BBC Urdu Article";
        }

        // =============================================
        // AUTHENTICATION FUNCTIONS
        // =============================================
        
        // Initialize authentication
        async function initAuth() {
            if (!supabaseClient) {
                console.log('Supabase client not initialized yet')
                return
            }
            
            try {
                // Get current session
                const { data: { session } } = await supabaseClient.auth.getSession()
                if (session) {
                    currentUser = session.user
                    updateAuthUI()
                    await loadUserVocabulary()
                }
                
                // Listen for auth changes
                supabaseClient.auth.onAuthStateChange(async (event, session) => {
                    if (event === 'SIGNED_IN') {
                        currentUser = session.user
                        updateAuthUI()
                        await migrateLocalVocabulary()
                        await loadUserVocabulary()
                    } else if (event === 'SIGNED_OUT') {
                        currentUser = null
                        updateAuthUI()
                        vocabulary = []
                        updateVocabularyUI()
                    }
                })
            } catch (error) {
                console.error('Auth initialization error:', error)
            }
        }
        
        // Sign in with Google
        async function signInWithGoogle() {
            if (!supabaseClient) {
                alert('Authentication system not ready. Please refresh the page.')
                return
            }
            
            try {
                const { error } = await supabaseClient.auth.signInWithOAuth({
                    provider: 'google'
                })
                if (error) throw error
            } catch (error) {
                console.error('Sign in error:', error)
                alert('Sign in failed. Please try again.')
            }
        }
        
        // Sign out
        async function signOut() {
            if (!supabaseClient) {
                alert('Authentication system not ready. Please refresh the page.')
                return
            }
            
            try {
                console.log('Signing out...')
                const { error } = await supabaseClient.auth.signOut()
                if (error) throw error
                
                // Manually handle sign out state cleanup
                currentUser = null
                vocabulary = []
                updateAuthUI()
                updateVocabularyUI()
                
                // Clear any localStorage as well
                localStorage.removeItem('vocabulary')
                
                console.log('Successfully signed out')
                alert('Successfully signed out!')
            } catch (error) {
                console.error('Sign out error:', error)
                alert('Sign out failed. Please try again.')
            }
        }
        
        // Update authentication UI
        function updateAuthUI() {
            const authSection = document.getElementById('authSection')
            
            if (currentUser) {
                authSection.innerHTML = `
                    <div class="user-info">
                        <img src="${currentUser.user_metadata.avatar_url || 'https://via.placeholder.com/32'}" 
                             alt="User avatar" class="user-avatar">
                        <span>${currentUser.user_metadata.full_name || currentUser.email}</span>
                        <button class="auth-button sign-out-btn" onclick="signOut()">Sign Out</button>
                    </div>
                `
            } else {
                authSection.innerHTML = `
                    <button class="auth-button" onclick="signInWithGoogle()">
                        üìß Sign in with Google
                    </button>
                `
            }
        }
        
        // Migrate existing localStorage vocabulary to user account
        async function migrateLocalVocabulary() {
            if (!currentUser) return
            
            try {
                const localVocab = JSON.parse(localStorage.getItem('vocabulary') || '[]')
                if (localVocab.length === 0) return
                
                // Check if user already has vocabulary in database
                const { data: existingVocab } = await supabaseClient
                    .from('user_vocabulary')
                    .select('urdu_word')
                    .eq('user_id', currentUser.id)
                
                const existingWords = new Set(existingVocab?.map(v => v.urdu_word) || [])
                
                // Only migrate words that don't already exist
                const wordsToMigrate = localVocab.filter(word => !existingWords.has(word.urdu))
                
                if (wordsToMigrate.length > 0) {
                    const { error } = await supabaseClient
                        .from('user_vocabulary')
                        .insert(wordsToMigrate.map(word => ({
                            user_id: currentUser.id,
                            urdu_word: word.urdu,
                            english_translation: word.english,
                            difficulty: word.difficulty || 'easy'
                        })))
                    
                    if (error) throw error
                    
                    // Clear localStorage after successful migration
                    localStorage.removeItem('vocabulary')
                    console.log(`Migrated ${wordsToMigrate.length} words to user account`)
                }
            } catch (error) {
                console.error('Migration error:', error)
            }
        }
        
        // Load user vocabulary from database (excluding soft-deleted)
        async function loadUserVocabulary() {
            if (!currentUser) return
            
            try {
                const { data, error } = await supabaseClient
                    .from('user_vocabulary')
                    .select('*')
                    .eq('user_id', currentUser.id)
                    .is('deleted_at', null)  // Filter out soft-deleted words
                    .order('created_at', { ascending: false })
                
                if (error) throw error
                
                vocabulary = data.map(item => ({
                    urdu: item.urdu_word,
                    english: item.english_translation,
                    difficulty: item.difficulty,
                    id: item.id,
                    story_index: item.story_index,
                    character_position: item.character_position,
                    saved_from_context: item.saved_from_context
                }))
                
                console.log(`Loaded ${vocabulary.length} active words from database:`, vocabulary)
                updateVocabularyUI()
            } catch (error) {
                console.error('Load vocabulary error:', error)
                // Fallback to localStorage if database fails
                const localVocab = JSON.parse(localStorage.getItem('vocabulary') || '[]')
                vocabulary = localVocab
                updateVocabularyUI()
            }
        }
        
        // Save vocabulary word to database with location context
        async function saveVocabularyToDatabase(urdu, english, difficulty = 'easy', locationContext = null) {
            if (!currentUser) {
                // Fallback to localStorage if not signed in
                saveToLocalStorage(urdu, english, difficulty)
                return
            }
            
            try {
                const insertData = {
                    user_id: currentUser.id,
                    urdu_word: urdu,
                    english_translation: english,
                    difficulty: difficulty
                };
                
                // Add location context if available
                if (locationContext) {
                    insertData.story_index = locationContext.story_index;
                    insertData.character_position = locationContext.character_position; 
                    insertData.saved_from_context = locationContext.saved_from_context;
                    console.log('Saving with location context:', locationContext);
                }
                
                const { data, error } = await supabaseClient
                    .from('user_vocabulary')
                    .insert(insertData)
                    .select()
                    .single()
                
                if (error) throw error
                
                // Add to local vocabulary array
                vocabulary.unshift({
                    urdu: urdu,
                    english: english,
                    difficulty: difficulty,
                    id: data.id,
                    story_index: locationContext?.story_index,
                    character_position: locationContext?.character_position,
                    saved_from_context: locationContext?.saved_from_context
                })
                
                updateVocabularyUI()
            } catch (error) {
                console.error('Save vocabulary error:', error)
                // Fallback to localStorage
                saveToLocalStorage(urdu, english, difficulty)
            }
        }
        
        // Update vocabulary difficulty in database
        async function updateVocabularyDifficulty(wordId, newDifficulty) {
            if (!currentUser) {
                console.log('No current user - cannot update difficulty in database')
                return
            }
            
            if (!wordId) {
                console.error('No wordId provided for difficulty update')
                return
            }
            
            console.log(`Updating difficulty for word ID ${wordId} to ${newDifficulty}`)
            
            try {
                const { data, error } = await supabaseClient
                    .from('user_vocabulary')
                    .update({ difficulty: newDifficulty })
                    .eq('id', wordId)
                    .eq('user_id', currentUser.id)
                    .select()
                
                if (error) throw error
                
                console.log('Difficulty update successful:', data)
            } catch (error) {
                console.error('Update difficulty error:', error)
                alert(`Failed to update difficulty: ${error.message}`)
            }
        }
        
        // Soft delete vocabulary word from database
        async function deleteVocabularyFromDatabase(wordId) {
            if (!currentUser) return
            
            console.log(`Soft deleting word ID: ${wordId}`)
            
            try {
                const { data, error } = await supabaseClient
                    .from('user_vocabulary')
                    .update({ deleted_at: new Date().toISOString() })
                    .eq('id', wordId)
                    .eq('user_id', currentUser.id)
                    .select()
                
                if (error) throw error
                console.log('Soft delete successful:', data)
            } catch (error) {
                console.error('Soft delete error:', error)
                alert(`Failed to delete word: ${error.message}`)
            }
        }
        
        // Fallback localStorage functions for non-authenticated users
        function saveToLocalStorage(urdu, english, difficulty) {
            vocabulary.unshift({ urdu, english, difficulty })
            localStorage.setItem('vocabulary', JSON.stringify(vocabulary))
            updateVocabularyUI()
        }
        
        // Update vocabulary UI (unified function for both mobile and desktop)
        function updateVocabularyUI() {
            updateVocabulary() // Update desktop sidebar
            renderMobileVocabulary() // Update mobile modal
            updateVocabBadge() // Update mobile badge count
        }

        // =============================================
        // BBC ARTICLE FUNCTIONS
        // =============================================

        // Fetch and add BBC Urdu article from local HTML file
        async function loadBBCArticle() {
            if (bbcArticleLoaded) return;
            
            try {
                // Fetch from your local HTML file
                const htmlFileName = 'Sheet1.html';
                console.log("Loading BBC article from local HTML file:", htmlFileName);
                
                const response = await fetch(htmlFileName);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const htmlText = await response.text();
                
                console.log("HTML data received:", htmlText.length, "characters");
                
                // Parse HTML table to get Row 1 only
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlText;
                
                // Find the first table
                const tables = tempDiv.querySelectorAll('table');
                console.log("Found", tables.length, "tables in HTML");
                
                if (tables.length > 0) {
                    const firstTable = tables[0];
                    const rows = firstTable.querySelectorAll('tr');
                    console.log("Found", rows.length, "rows in first table");
                    
                    // Find Row 1, Row 2, and Row 3 with actual data (not headers)
                    let rowsProcessed = 0;
                    for (let i = 0; i < rows.length && rowsProcessed < 3; i++) {
                        const cells = rows[i].querySelectorAll('td');
                        if (cells.length > 0) {
                            // Check if this row has Urdu content
                            const hasUrduContent = Array.from(cells).some(cell => {
                                const text = cell.textContent.trim();
                                return text.length > 20 && /[\u0600-\u06FF]/.test(text);
                            });
                            
                            if (hasUrduContent) {
                                rowsProcessed++;
                                console.log(`Processing Row ${rowsProcessed}: Found ${cells.length} cells`);
                                
                                let title = "BBC Article";
                                let content = "";
                                
                                // Get title from first cell (A column)
                                if (cells[0] && cells[0].textContent.trim().length > 5) {
                                    title = cells[0].textContent.trim();
                                    console.log(`A${rowsProcessed} title:`, title.substring(0, 50));
                                }
                                
                                // Get content from H cell (column 7, 0-indexed)
                                const hCellIndex = 7;
                                if (cells[hCellIndex]) {
                                    let hContent = cells[hCellIndex].textContent.trim();
                                    
                                    // Clean image metadata from the beginning
                                    hContent = cleanImageMetadata(hContent);
                                    
                                    if (hContent.length > 50) {
                                        content = cleanLocalHTMLContent(hContent);
                                        console.log(`H${rowsProcessed} content length:`, content.length);
                                    }
                                }
                                
                                if (content.length > 50) {
                                    // Add to stories array
                                    stories.push(content);
                                    
                                    // Add to dropdown with AI-optimized headline
                                    const storySelect = document.getElementById('storySelect');
                                    const option = document.createElement('option');
                                    option.value = stories.length - 1;
                                    
                                    // Create AI-optimized English headline
                                    const optimizedHeadline = createOptimizedHeadline(title);
                                    option.textContent = `${stories.length}. ${optimizedHeadline}`;
                                    
                                    storySelect.appendChild(option);
                                    console.log(`Added BBC article ${rowsProcessed} with headline:`, optimizedHeadline);
                                }
                            }
                        }
                    }
                    
                    if (rowsProcessed === 0) {
                        console.log("No rows with Urdu content found");
                    } else {
                        console.log(`Successfully processed ${rowsProcessed} BBC articles`);
                    }
                } else {
                    console.log("No tables found in HTML file");
                }
                
                // Re-initialize pages
                initializePages();
                
                bbcArticleLoaded = true;
                console.log("BBC article loaded successfully");
                
            } catch (error) {
                console.error("Error loading BBC article:", error);
            }
        }


        // Clean image metadata from article content
        function cleanImageMetadata(content) {
            // Remove image source metadata that starts articles - more aggressive
            content = content.replace(/^ÿåÿ™ÿµŸà€åÿ± ⁄©ÿß ÿ∞ÿ±€åÿπ€Å.*?(?=Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ|ÿßŸÜ⁄à€åÿß|ÿßŸÖÿ±€å⁄©€Å|[ÿ¢ÿßÿ®Ÿæÿ™ÿ´ÿ¨])/s, '');
            content = content.replace(/^Getty Images.*?(?=Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ|ÿßŸÜ⁄à€åÿß|ÿßŸÖÿ±€å⁄©€Å|[ÿ¢ÿßÿ®Ÿæÿ™ÿ´ÿ¨])/s, '');
            content = content.replace(/^Reuters.*?(?=Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ|ÿßŸÜ⁄à€åÿß|ÿßŸÖÿ±€å⁄©€Å|[ÿ¢ÿßÿ®Ÿæÿ™ÿ´ÿ¨])/s, '');
            content = content.replace(/^AFP.*?(?=Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ|ÿßŸÜ⁄à€åÿß|ÿßŸÖÿ±€å⁄©€Å|[ÿ¢ÿßÿ®Ÿæÿ™ÿ´ÿ¨])/s, '');
            
            // Remove other metadata patterns throughout content
            content = content.replace(/ÿåÿ™ÿµŸà€åÿ± ⁄©ÿß ÿ∞ÿ±€åÿπ€Å[^€î]*€î?\s*/g, ' ');
            content = content.replace(/Getty Images[^€î]*€î?\s*/g, ' ');
            content = content.replace(/Reuters[^€î]*€î?\s*/g, ' ');
            content = content.replace(/AFP[^€î]*€î?\s*/g, ' ');
            content = content.replace(/Image[^€î]*€î?\s*/g, ' ');
            content = content.replace(/ÿ™ÿµŸà€åÿ±[^€î]*€î?\s*/g, ' ');
            content = content.replace(/ÿ∞ÿ±€åÿπ€Å[^€î]*€î?\s*/g, ' ');
            
            // Remove "End of" sections
            content = content.replace(/End of[^€î]*€î?\s*/g, ' ');
            
            // Remove social media and sharing text
            content = content.replace(/ÿ®€å ÿ®€å ÿ≥€å ÿßÿ±ÿØŸà ⁄©€å ÿÆÿ®ÿ±Ÿà⁄∫[^€î]*€î?\s*/g, ' ');
            content = content.replace(/ÿ≥ÿ®ÿ≥⁄©ÿ±ÿßÿ¶ÿ® ⁄©ÿ±ŸÜ€í ⁄©€í ŸÑ€å€í[^€î]*€î?\s*/g, ' ');
            content = content.replace(/ŸÖŸàÿßÿØ Ÿæÿ± ÿ¨ÿßÿ¶€å⁄∫\s*/g, ' ');
            
            // Remove metadata at the beginning that starts with image references
            content = content.replace(/^[^ÿ¢ÿßÿ®Ÿæÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ŸÅŸÇ⁄©⁄ØŸÑŸÖŸÜŸà€Å€å€í]*([ÿ¢ÿßÿ®Ÿæÿ™ÿ´ÿ¨ÿ≠ÿÆÿØÿ∞ÿ±ÿ≤ÿ≥ÿ¥ÿµÿ∂ÿ∑ÿ∏ÿπÿ∫ŸÅŸÇ⁄©⁄ØŸÑŸÖŸÜŸà€Å€å€í])/, '$1');
            
            // Clean up multiple spaces and line breaks
            content = content.replace(/\s+/g, ' ').trim();
            
            return content;
        }

        // Clean content from local HTML file
        function cleanLocalHTMLContent(content) {
            // Remove extra whitespace
            content = content.replace(/\s+/g, ' ').trim();
            
            // Remove any remaining HTML entities
            content = content.replace(/&quot;/g, '"');
            content = content.replace(/&amp;/g, '&');
            content = content.replace(/&lt;/g, '<');
            content = content.replace(/&gt;/g, '>');
            content = content.replace(/&nbsp;/g, ' ');
            
            // Ensure proper sentence endings
            if (!content.endsWith('€î') && !content.endsWith('!') && !content.endsWith('ÿü')) {
                content += '€î';
            }
            
            return content;
        }

        // Parse CSV row handling quoted fields
        function parseCSVRow(row) {
            const result = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < row.length; i++) {
                const char = row[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    result.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            
            result.push(current.trim());
            return result;
        }

        // Clean content from Google Sheets
        function cleanGoogleSheetContent(content) {
            // Remove extra quotes that might come from CSV
            content = content.replace(/^["']|["']$/g, '');
            
            // Normalize whitespace
            content = content.replace(/\s+/g, ' ').trim();
            
            // Remove any remaining HTML entities or artifacts
            content = content.replace(/&quot;/g, '"');
            content = content.replace(/&amp;/g, '&');
            content = content.replace(/&lt;/g, '<');
            content = content.replace(/&gt;/g, '>');
            
            // Ensure proper sentence endings
            if (!content.endsWith('€î') && !content.endsWith('!') && !content.endsWith('ÿü')) {
                content += '€î';
            }
            
            return content;
        }

        // Extract clean text from article HTML
        function extractArticleText(html) {
            // First decode any URL encoding in the HTML
            try {
                html = decodeURIComponent(html);
            } catch (e) {
                // If decoding fails, continue with original
            }
            
            // Create a temporary div to parse HTML
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            
            console.log("Full HTML content length:", html.length);
            console.log("Parsed DOM - total paragraphs found:", tempDiv.querySelectorAll('p').length);
            
            // Check if BBC is using JSON-LD structured data for the article
            const jsonLdScripts = tempDiv.querySelectorAll('script[type="application/ld+json"]');
            console.log("Found JSON-LD scripts:", jsonLdScripts.length);
            
            for (let script of jsonLdScripts) {
                try {
                    const jsonData = JSON.parse(script.textContent);
                    if (jsonData.articleBody || (jsonData['@type'] === 'NewsArticle' && jsonData.text)) {
                        const structuredText = jsonData.articleBody || jsonData.text;
                        console.log("Found structured article text:", structuredText.length, "characters");
                        if (structuredText.length > 500) {
                            return structuredText;
                        }
                    }
                } catch (e) {
                    console.log("Failed to parse JSON-LD:", e.message);
                }
            }
            
            // AGGRESSIVE image and media removal first - before any content extraction
            const mediaElements = tempDiv.querySelectorAll(`
                img, video, audio, iframe, embed, object,
                figure, picture, 
                [class*="image"], [class*="photo"], [class*="video"], [class*="media"],
                [data-component="image"], [data-component="video"], [data-component="media"],
                .media, .image-wrapper, .video-wrapper, .photo-wrapper,
                .caption, .photo-caption, .image-caption,
                .credit, .photo-credit, .image-credit,
                .copyright, .getty-image, .afp-image,
                .share-tools, .social-share, .share-buttons,
                .related-content, .related-links, .see-also,
                .tags, .topic-tags, .story-tags,
                .byline, .author-info, .dateline, .timestamp,
                nav, header, footer, aside,
                .advertisement, .ad, .sponsored,
                script, style, noscript
            `);
            
            console.log(`Removing ${mediaElements.length} media/unwanted elements`);
            mediaElements.forEach(el => el.remove());
            
            // Try BBC-specific selectors for main content
            let articleContent = tempDiv.querySelector('[data-component="text-block"]') ||
                                tempDiv.querySelector('.story-body__inner') ||
                                tempDiv.querySelector('.story-body') ||
                                tempDiv.querySelector('.qa-story-body') ||
                                tempDiv.querySelector('article') ||
                                tempDiv.querySelector('.main-content') ||
                                tempDiv.querySelector('#main-content') ||
                                tempDiv.querySelector('[role="main"]');
            
            // If no main container found, collect ALL paragraphs from entire document
            if (!articleContent) {
                console.log("No main container found, collecting all paragraphs");
                const allParagraphs = tempDiv.querySelectorAll('p');
                console.log(`Found ${allParagraphs.length} total paragraphs`);
                
                if (allParagraphs.length > 0) {
                    articleContent = document.createElement('div');
                    
                    // Filter and add paragraphs that contain actual Urdu content
                    allParagraphs.forEach((p, index) => {
                        const text = p.textContent.trim();
                        
                        // Check if paragraph contains meaningful Urdu text
                        const hasUrduChars = /[\u0600-\u06FF]/.test(text); // Arabic/Urdu Unicode range
                        const isLongEnough = text.length > 15;
                        const notMetadata = !text.match(/^(Share|Published|Updated|By|Getty|AFP|Reuters|BBC)/i);
                        const notNavigation = !text.match(/^(Home|News|Sport|Weather|Politics)/i);
                        
                        if (hasUrduChars && isLongEnough && notMetadata && notNavigation) {
                            console.log(`Including paragraph ${index}: "${text.substring(0, 80)}..."`);
                            articleContent.appendChild(p.cloneNode(true));
                        } else {
                            console.log(`Skipping paragraph ${index}: "${text.substring(0, 50)}..." (Urdu: ${hasUrduChars}, Long: ${isLongEnough})`);
                        }
                    });
                }
            } else {
                console.log("Main container found, using it");
            }
            
            if (articleContent) {
                // Final cleanup of any remaining unwanted elements
                const finalUnwanted = articleContent.querySelectorAll(`
                    script, style, img, video, iframe, nav, footer, header, aside,
                    .ad, .advertisement, .share, .social, .related, .tags, .metadata,
                    [class*="share"], [class*="social"], [class*="ad"], [class*="promo"]
                `);
                finalUnwanted.forEach(el => el.remove());
                
                // Extract text while preserving paragraph structure
                const paragraphs = articleContent.querySelectorAll('p');
                const validParagraphs = [];
                
                console.log(`Processing ${paragraphs.length} paragraphs for content`);
                
                paragraphs.forEach((p, index) => {
                    let text = p.textContent || p.innerText;
                    
                    // Decode URL encoding if present
                    try {
                        text = decodeURIComponent(text);
                    } catch (e) {
                        // If decoding fails, continue with original
                    }
                    
                    // Basic cleaning while preserving structure
                    text = text.trim();
                    text = text.replace(/\s+/g, ' '); // Normalize whitespace but don't remove all structure
                    
                    // Light cleaning - only remove obvious artifacts
                    text = text.replace(/\b(Share|Published|Updated|Getty Images|Reuters|AFP)\s*/gi, '');
                    text = text.replace(/^\W+/, ''); // Remove leading punctuation/symbols
                    
                    // Check if this paragraph has meaningful Urdu content
                    const hasUrduChars = /[\u0600-\u06FF]/.test(text);
                    const isLongEnough = text.length > 20;
                    const notJustMetadata = !text.match(/^(By|Published|Updated|Getty|AFP|Reuters|BBC|Share|Home|News)[\s\W]/i);
                    
                    if (hasUrduChars && isLongEnough && notJustMetadata && !text.includes('%D8%')) {
                        console.log(`Including paragraph ${index}: "${text.substring(0, 100)}..."`);
                        validParagraphs.push(text);
                    } else {
                        console.log(`Skipping paragraph ${index}: "${text.substring(0, 60)}..." (reasons: Urdu=${hasUrduChars}, Length=${isLongEnough}, NotMeta=${notJustMetadata})`);
                    }
                });
                
                // Join paragraphs with proper spacing to preserve structure
                let fullText = validParagraphs.join(' ');
                
                // Final light cleanup
                fullText = fullText.replace(/\s+/g, ' ').trim();
                fullText = fullText.replace(/\s*[€î!ÿü]\s*[€î!ÿü]+/g, '€î '); // Fix multiple punctuation
                
                // Don't limit word count - take the FULL article for complete learning
                console.log(`Full article: ${validParagraphs.length} paragraphs, ${fullText.length} characters`);
                
                // Only ensure it ends properly
                if (fullText && !fullText.endsWith('€î') && !fullText.endsWith('!') && !fullText.endsWith('ÿü')) {
                    fullText += '€î';
                }
                
                // Return full article if we have meaningful content
                if (fullText.length > 200) {
                    console.log(`Returning complete article with ${fullText.length} characters`);
                    return fullText;
                } else {
                    console.log("Not enough content after processing");
                    return null;
                }
            }
            
            console.log("No article content could be extracted");
            return null;
        }

        // Split stories into pages (3 sentences per page)
        function initializePages() {
            pagesPerStory = stories.map(story => {
                // Simple approach: find sentences by splitting on punctuation and keeping them intact
                const sentences = [];
                let currentSentence = '';
                
                for (let i = 0; i < story.length; i++) {
                    currentSentence += story[i];
                    
                    // Check if we hit a sentence ending
                    if (story[i] === '€î' || story[i] === '!' || story[i] === 'ÿü') {
                        sentences.push(currentSentence.trim());
                        currentSentence = '';
                        
                        // Skip any whitespace after punctuation
                        while (i + 1 < story.length && story[i + 1] === ' ') {
                            i++;
                        }
                    }
                }
                
                // Add any remaining text as a sentence
                if (currentSentence.trim()) {
                    sentences.push(currentSentence.trim());
                }
                
                // Group sentences into pages (IMPROVED: More sentences per page for better reading)
                const pages = [];
                const sentencesPerPage = 12; // Increased from 3 to 12 for better reading experience
                
                for (let i = 0; i < sentences.length; i += sentencesPerPage) {
                    const pageSentences = sentences.slice(i, i + sentencesPerPage);
                    const pageText = pageSentences.join(' ');
                    
                    if (pageText.trim()) {
                        pages.push(pageText);
                    }
                }
                
                return pages.length > 0 ? pages : [story];
            });
        }

        // Load story
        function loadStory(index) {
            currentPage = 0;
            isTranslated = false;
            document.getElementById('translateToggle').textContent = 'Translate to English';
            document.getElementById('translateToggle').classList.remove('translating');
            loadCurrentPage(index);
            updatePageNavigation(index);
            
            // Check if this is a novel episode and mark progress
            checkAndMarkNovelEpisode(parseInt(index));
        }

        // Load current page
        function loadCurrentPage(storyIndex) {
            const currentStoryPages = pagesPerStory[storyIndex];
            const text = currentStoryPages[currentPage];
            
            if (!text) return;
            
            // Split by spaces but handle punctuation properly for RTL
            const words = text.split(' ');
            const html = words.map((word, i) => {
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                const isSaved = vocabulary.some(item => item.urdu === cleanWord || item.urdu.includes(cleanWord));
                const savedClass = isSaved ? ' saved' : '';
                
                // For RTL text, wrap each word (including punctuation) in a span
                // Use Unicode RLE (Right-to-Left Embedding) and PDF (Pop Directional Formatting)
                return `<span class="urdu-word${savedClass}" 
                    onmousedown="handleWord('${word.replace(/'/g, "\\'")}', ${i}, event)"
                    onmouseenter="handleWordEnter(${i}, this)"
                    ontouchstart="handleTouchStart('${word.replace(/'/g, "\\'")}', ${i}, event)"
                    ontouchmove="handleTouchMove(${i}, event)"
                    ontouchend="handleTouchEnd(event)"
                    data-word-index="${i}"
                    dir="rtl"
                >${word}</span>`;
            }).join(' ');
            
            // Ensure proper Urdu formatting
            const textElement = document.getElementById('urduText');
            textElement.innerHTML = html;
            textElement.style.direction = 'rtl';
            textElement.style.textAlign = 'right';
            textElement.style.fontFamily = "'Noto Nastaliq Urdu', serif";
            
            selectedWords = [];
            isSelecting = false;
            updateSelectionUI();
        }

        // Update page navigation
        function updatePageNavigation(storyIndex) {
            const currentStoryPages = pagesPerStory[storyIndex];
            const totalPages = currentStoryPages.length;
            
            document.getElementById('pageInfo').textContent = `Page ${currentPage + 1} of ${totalPages}`;
            document.getElementById('prevPageBtn').disabled = currentPage === 0;
            document.getElementById('nextPageBtn').disabled = currentPage === totalPages - 1;
        }

        // Previous page
        function previousPage() {
            if (currentPage > 0) {
                currentPage--;
                const storyIndex = parseInt(document.getElementById('storySelect').value);
                loadCurrentPage(storyIndex);
                updatePageNavigation(storyIndex);
                
                // Reset translation state and styling for new page
                isTranslated = false;
                document.getElementById('translateToggle').textContent = 'Translate to English';
                document.getElementById('translateToggle').classList.remove('translating');
                
                // Reset text direction to Urdu
                const textElement = document.getElementById('urduText');
                textElement.style.direction = 'rtl';
                textElement.style.textAlign = 'right';
                textElement.style.fontFamily = "'Noto Nastaliq Urdu', serif";
            }
        }

        // Next page
        function nextPage() {
            const storyIndex = parseInt(document.getElementById('storySelect').value);
            const totalPages = pagesPerStory[storyIndex].length;
            
            if (currentPage < totalPages - 1) {
                currentPage++;
                loadCurrentPage(storyIndex);
                updatePageNavigation(storyIndex);
                
                // Reset translation state and styling for new page
                isTranslated = false;
                document.getElementById('translateToggle').textContent = 'Translate to English';
                document.getElementById('translateToggle').classList.remove('translating');
                
                // Reset text direction to Urdu
                const textElement = document.getElementById('urduText');
                textElement.style.direction = 'rtl';
                textElement.style.textAlign = 'right';
                textElement.style.fontFamily = "'Noto Nastaliq Urdu', serif";
            }
        }

        // Toggle page translation
        async function togglePageTranslation() {
            const toggleBtn = document.getElementById('translateToggle');
            const storyIndex = parseInt(document.getElementById('storySelect').value);
            const pageKey = `${storyIndex}-${currentPage}`;
            
            if (toggleBtn.classList.contains('translating')) return;
            
            if (isTranslated) {
                // Switch back to Urdu
                isTranslated = false;
                toggleBtn.textContent = 'Translate to English';
                loadCurrentPage(storyIndex);
            } else {
                // Translate to English
                toggleBtn.textContent = 'Translating...';
                toggleBtn.classList.add('translating');
                
                // Check if translation is cached
                if (translatedPages.has(pageKey)) {
                    displayTranslatedPage(translatedPages.get(pageKey));
                    isTranslated = true;
                    toggleBtn.textContent = 'Show Urdu';
                    toggleBtn.classList.remove('translating');
                } else {
                    // Translate the page
                    const currentText = pagesPerStory[storyIndex][currentPage];
                    try {
                        const translation = await translateText(currentText);
                        translatedPages.set(pageKey, translation);
                        displayTranslatedPage(translation);
                        isTranslated = true;
                        toggleBtn.textContent = 'Show Urdu';
                    } catch (error) {
                        alert('Translation failed. Please try again.');
                        toggleBtn.textContent = 'Translate to English';
                    }
                    toggleBtn.classList.remove('translating');
                }
            }
        }

        // Display translated page
        function displayTranslatedPage(translation) {
            const words = translation.split(' ');
            const html = words.map((word, i) => 
                `<span class="urdu-word" style="direction: ltr;" dir="ltr">${word}</span>`
            ).join(' ');
            
            const textElement = document.getElementById('urduText');
            textElement.innerHTML = html;
            textElement.style.direction = 'ltr';
            textElement.style.textAlign = 'left';
            textElement.style.fontFamily = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif';
        }

        // Handle word click (start selection or toggle)
        async function handleWord(word, index, event) {
            const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
            
            // Check if this word is already selected/highlighted
            if (event.target.classList.contains('selected') || event.target.classList.contains('active')) {
                // Toggle off - unhighlight and hide popup
                event.target.classList.remove('active', 'selected');
                selectedWords = [];
                isSelecting = false;
                hideMobileTranslation();
                return;
            }
            
            // Clear previous selections
            document.querySelectorAll('.urdu-word').forEach(w => {
                w.classList.remove('active');
                w.classList.remove('selected');
            });
            
            // Start new selection
            selectedWords = [index];
            event.target.classList.add('selected');
            isSelecting = true;
            selectionStart = index;
            
            // Translate single word immediately
            try {
                // Check cache
                if (translationCache.has(cleanWord)) {
                    showTranslation(cleanWord, translationCache.get(cleanWord), event.target);
                    return;
                }
                
                document.getElementById('translationContent').innerHTML = 'Translating...';
                const translation = await translateText(cleanWord);
                translationCache.set(cleanWord, translation);
                showTranslation(cleanWord, translation, event.target);
            } catch (error) {
                showTranslation(cleanWord, 'Translation error', event.target);
            }
        }

        // Handle mouse enter for drag selection
        function handleWordEnter(index, element) {
            if (!isSelecting) return;
            
            // Clear current selection
            document.querySelectorAll('.urdu-word').forEach(w => w.classList.remove('selected'));
            
            // Select range from start to current
            const start = Math.min(selectionStart, index);
            const end = Math.max(selectionStart, index);
            
            selectedWords = [];
            const words = document.querySelectorAll('.urdu-word');
            
            for (let i = start; i <= end; i++) {
                selectedWords.push(i);
                words[i].classList.add('selected');
            }
            
            // Update UI to show selection count
            if (selectedWords.length > 1) {
                updateSelectionUI();
            }
        }

        // Handle mouse up (end selection)
        function handleMouseUp() {
            if (isSelecting && selectedWords.length > 1) {
                // Translate the selected phrase
                translateSelectedWords();
            } else if (isSelecting && selectedWords.length === 1) {
                // Single word was selected, translation already handled in handleWord
            }
            isSelecting = false;
        }

        // Update selection UI
        function updateSelectionUI() {
            const content = document.getElementById('translationContent');
            
            if (selectedWords.length === 0) {
                content.innerHTML = 'Click any Urdu word to see its translation, or drag to select multiple words';
            } else if (selectedWords.length === 1) {
                // Single word selection - translation handled in handleWord
                return;
            } else {
                content.innerHTML = `${selectedWords.length} words selected. Release mouse to translate phrase...`;
            }
        }

        // Translate selected words as phrase
        async function translateSelectedWords() {
            if (selectedWords.length === 0) return;
            
            // Sort indices and get words
            const sortedIndices = selectedWords.sort((a, b) => a - b);
            const words = document.querySelectorAll('.urdu-word');
            const phrase = sortedIndices.map(i => words[i].textContent).join(' ');
            const cleanPhrase = phrase.replace(/[€îÿåÿü!]/g, '');
            
            // Check cache
            if (translationCache.has(cleanPhrase)) {
                const firstElement = words[sortedIndices[0]];
                showTranslation(cleanPhrase, translationCache.get(cleanPhrase), firstElement);
                return;
            }
            
            // Show loading
            document.getElementById('translationContent').innerHTML = 'Translating phrase...';
            
            try {
                const translation = await translateText(cleanPhrase);
                translationCache.set(cleanPhrase, translation);
                const firstElement = words[sortedIndices[0]];
                showTranslation(cleanPhrase, translation, firstElement);
            } catch (error) {
                const firstElement = words[sortedIndices[0]];
                showTranslation(cleanPhrase, 'Translation error', firstElement);
            }
        }

        // Common translation function - uses Vercel API
        async function translateText(text) {
            // Detect environment and use appropriate translation method
            const isLocalPythonServer = window.location.hostname === '127.0.0.1' && window.location.port === '8000';
            const isVercelDev = window.location.hostname === 'localhost' && window.location.port === '3000';
            const isProduction = window.location.hostname.includes('vercel.app');
            
            if (isLocalPythonServer) {
                // Running on Python server - use direct API call with local env
                return await translateWithLocalEnv(text);
            } else if (isVercelDev || isProduction) {
                // Running on Vercel (dev or production) - use serverless function
                return await translateWithServerless(text);
            } else {
                // Fallback
                return await translateWithServerless(text);
            }
        }

        // Translation via Vercel serverless function (dev + production)
        async function translateWithServerless(text) {
            const response = await fetch('/api/translate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ text: text })
            });
            
            if (!response.ok) {
                throw new Error(`Translation failed: ${response.status}`);
            }
            
            const data = await response.json();
            return data.translation || 'Translation not found';
        }

        // Direct translation with local environment variables
        async function translateWithLocalEnv(text) {
            // This would need the API key - for security, we'll fall back to serverless
            // In a real app, you'd load this from your local .env file via a local server
            console.log('Local Python server detected - falling back to mock for security');
            
            // Simple mock for local testing (replace with real implementation)
            const quickMocks = {
                'Ÿæÿß⁄©ÿ≥ÿ™ÿßŸÜ': 'Pakistan', 'ÿ≥€åŸÜ€åŸπ': 'Senate', 'ÿ®ŸêŸÑ': 'bill',
                'ÿ≥Ÿàÿ¥ŸÑ': 'social', 'ŸÖ€å⁄à€åÿß': 'media', 'ÿ®⁄ÜŸà⁄∫': 'children'
            };
            
            await new Promise(resolve => setTimeout(resolve, 300)); // Simulate delay
            return quickMocks[text] || `[Local: ${text}]`;
        }

        // Show translation in appropriate location based on device
        function showTranslation(word, translation, element) {
            // Store current translation for save button
            currentPopupWord = word;
            currentPopupTranslation = translation;

            // Check if mobile
            const isMobile = window.innerWidth < 768;
            
            if (isMobile) {
                // Show in mobile bottom bar
                document.getElementById('mobileWord').textContent = word;
                document.getElementById('mobileTranslation').textContent = translation;
                document.getElementById('mobileTranslationBar').classList.add('show');
            } else {
                // Show in desktop sidebar
                const isPhrase = word.includes(' ');
                const buttonText = isPhrase ? 'Save Phrase' : 'Save Word';
                
                document.getElementById('translationContent').innerHTML = `
                    <div style="margin-bottom: 12px;">
                        <div style="font-family: 'Noto Nastaliq Urdu', serif; font-size: 18px; font-weight: bold; color: #1f2937; margin-bottom: 6px;">${word}</div>
                        <div style="font-size: 16px; color: #4b5563; margin-bottom: 12px;">${translation}</div>
                        <button onclick="saveDesktopWord()" style="background: #10b981; color: white; border: none; padding: 8px 16px; border-radius: 8px; font-size: 14px; cursor: pointer;">${buttonText}</button>
                    </div>
                `;
            }
        }
        
        // Hide mobile translation bar
        function hideMobileTranslation() {
            document.getElementById('mobileTranslationBar').classList.remove('show');
        }

        // Save word from mobile bar
        function saveMobileWord() {
            if (currentPopupWord && currentPopupTranslation) {
                saveWord(currentPopupWord, currentPopupTranslation);
                hideMobileTranslation();
            }
        }

        // Save word from desktop sidebar
        function saveDesktopWord() {
            if (currentPopupWord && currentPopupTranslation) {
                saveWord(currentPopupWord, currentPopupTranslation);
                
                // Reset translation content
                document.getElementById('translationContent').innerHTML = 'Click any Urdu word to see its translation';
            }
        }

        // Show mobile vocabulary modal
        function showMobileVocab() {
            renderMobileVocabulary();
            document.getElementById('mobileVocabModal').classList.add('show');
        }

        // Hide mobile vocabulary modal
        function hideMobileVocab() {
            document.getElementById('mobileVocabModal').classList.remove('show');
            // Show brief confirmation that changes are saved
            showSaveConfirmation();
        }
        
        // Show save confirmation
        function showSaveConfirmation() {
            // Create temporary notification
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #10b981;
                color: white;
                padding: 12px 20px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 3000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.2);
                transition: all 0.3s ease;
            `;
            notification.textContent = '‚úì Changes saved automatically';
            document.body.appendChild(notification);
            
            // Remove after 2 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 2000);
        }
        
        // Close modal when clicking outside
        function closeMobileVocabOnOverlay(event) {
            // Only close if clicking the overlay itself, not the content
            if (event.target === event.currentTarget) {
                hideMobileVocab();
            }
        }

        // State for vocabulary filtering
        let showCurrentStoryOnly = true;
        let currentDifficultyFilter = 'all'; // 'all', 'easy', 'medium', 'hard'

        // Render mobile vocabulary list
        function renderMobileVocabulary() {
            const mobileVocabList = document.getElementById('mobileVocabList');
            const currentStoryIndex = parseInt(document.getElementById('storySelect').value);
            
            // Filter vocabulary based on current setting
            let displayVocab = vocabulary;
            if (showCurrentStoryOnly) {
                displayVocab = vocabulary.filter(item => {
                    // Check if word exists in current story
                    const currentStory = stories[currentStoryIndex] || '';
                    return currentStory.includes(item.urdu);
                });
            }
            
            // Filter by difficulty
            if (currentDifficultyFilter !== 'all') {
                displayVocab = displayVocab.filter(item => {
                    const difficulty = item.difficulty || 'medium'; // Default for old words
                    return difficulty === currentDifficultyFilter;
                });
            }
            
            if (displayVocab.length === 0) {
                const message = showCurrentStoryOnly ? 'No saved words from this story' : 'No saved words yet';
                mobileVocabList.innerHTML = `<div style="text-align: center; color: #6b7280; padding: 20px;">${message}</div>`;
            } else {
                mobileVocabList.innerHTML = displayVocab.map((item, index) => {
                    const originalIndex = vocabulary.indexOf(item);
                    const difficulty = item.difficulty || 'medium'; // Default for old words
                    return `
                        <div class="mobile-vocab-item">
                            <div class="vocab-item-left">
                                <span class="difficulty-dot difficulty-dot-large difficulty-${difficulty}" onclick="cycleDifficulty(${originalIndex})" title="Tap to change difficulty"></span>
                                <div class="vocab-item-text">
                                    <div class="mobile-vocab-word">${item.urdu}</div>
                                    <div class="mobile-vocab-translation">${item.english}</div>
                                </div>
                            </div>
                            <div class="mobile-vocab-actions">
                                <button onclick="goToWord('${item.urdu.replace(/'/g, "\\'")}', this)" style="background: #10b981; color: white; border: none; padding: 8px 14px; border-radius: 8px; font-size: 13px; cursor: pointer;">Go to</button>
                                <button onclick="removeMobileVocabItem(${originalIndex})" style="background: #ef4444; color: white; border: none; padding: 8px 12px; border-radius: 8px; font-size: 13px; cursor: pointer;">√ó</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Update filter button appearances
            updateFilterButtonStates();
            
            // Update filter status display
            updateFilterStatus();
            
            // Update badge count
            updateVocabBadge();
        }

        // Switch between Browse and Filter tabs
        function switchVocabTab(tabName) {
            // Update tab buttons
            document.querySelectorAll('.vocab-tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Update tab content
            document.querySelectorAll('.vocab-tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabName + 'Content').classList.add('active');
        }

        // Update filter button states
        function updateFilterButtonStates() {
            // Story filter buttons
            document.querySelectorAll('.filter-btn[id^="story"]').forEach(btn => btn.classList.remove('active'));
            const storyBtnId = showCurrentStoryOnly ? 'storyCurrentBtn' : 'storyAllBtn';
            document.getElementById(storyBtnId)?.classList.add('active');
            
            // Difficulty filter buttons
            document.querySelectorAll('.filter-btn[id^="diff"]').forEach(btn => btn.classList.remove('active'));
            const diffBtnId = `diff${currentDifficultyFilter.charAt(0).toUpperCase() + currentDifficultyFilter.slice(1)}Btn`;
            document.getElementById(diffBtnId)?.classList.add('active');
        }

        // Update vocabulary count badge
        function updateVocabBadge() {
            const badge = document.getElementById('topVocabBadge');
            if (badge) {
                badge.textContent = vocabulary.length;
                badge.style.display = vocabulary.length > 0 ? 'flex' : 'none';
            }
        }

        // Remove individual vocabulary item from mobile
        async function removeMobileVocabItem(index) {
            const word = vocabulary[index];
            if (word && confirm(`üóëÔ∏è Delete "${word.urdu}" (${word.english}) from vocabulary?`)) {
                console.log(`Deleting word at index ${index}:`, word);
                
                // Delete from database if user is authenticated
                if (currentUser && word.id) {
                    console.log(`User authenticated, soft deleting from database`);
                    await deleteVocabularyFromDatabase(word.id);
                    
                    // Reload vocabulary from database to reflect the soft delete
                    await loadUserVocabulary();
                } else {
                    console.log(`Anonymous user or no word ID, removing from localStorage only`);
                    
                    // Remove from local array for anonymous users
                    vocabulary.splice(index, 1);
                    
                    // Update localStorage for anonymous users
                    localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
                }
                
                // Update UI
                renderMobileVocabulary();
                updateVocabulary(); // Update desktop sidebar too
            }
        }

        // Set story filter
        function setStoryFilter(scope) {
            showCurrentStoryOnly = (scope === 'current');
            renderMobileVocabulary();
            updateFilterButtonStates();
        }

        // Set difficulty filter
        function setDifficultyFilter(difficulty) {
            currentDifficultyFilter = difficulty;
            renderMobileVocabulary();
            updateFilterButtonStates();
        }

        // Clear all filters
        function clearAllFilters() {
            showCurrentStoryOnly = true; // Reset to default
            currentDifficultyFilter = 'all'; // Reset to default
            renderMobileVocabulary();
            updateFilterButtonStates();
        }

        // Update filter status display
        function updateFilterStatus() {
            const filterStatusBar = document.getElementById('filterStatusBar');
            const filterStatusText = document.getElementById('filterStatusText');
            
            const hasFilters = !showCurrentStoryOnly || currentDifficultyFilter !== 'all';
            
            if (hasFilters) {
                filterStatusBar.style.display = 'flex';
                
                let statusParts = [];
                
                // Story scope filter
                if (!showCurrentStoryOnly) {
                    statusParts.push('All Stories');
                }
                
                // Difficulty filter
                if (currentDifficultyFilter !== 'all') {
                    const difficultyName = currentDifficultyFilter.charAt(0).toUpperCase() + currentDifficultyFilter.slice(1);
                    statusParts.push(`${difficultyName} only`);
                }
                
                const statusText = statusParts.length > 0 ? `üîç Filtered by: ${statusParts.join(', ')}` : '';
                
                // Count filtered vs total words
                const totalWords = vocabulary.length;
                const currentStoryIndex = parseInt(document.getElementById('storySelect').value);
                
                let displayVocab = vocabulary;
                if (showCurrentStoryOnly) {
                    displayVocab = vocabulary.filter(item => {
                        const currentStory = stories[currentStoryIndex] || '';
                        return currentStory.includes(item.urdu);
                    });
                }
                if (currentDifficultyFilter !== 'all') {
                    displayVocab = displayVocab.filter(item => {
                        const difficulty = item.difficulty || 'medium';
                        return difficulty === currentDifficultyFilter;
                    });
                }
                
                const filteredCount = displayVocab.length;
                const countText = ` | Showing ${filteredCount} of ${totalWords} words`;
                
                filterStatusText.innerHTML = statusText + countText;
            } else {
                filterStatusBar.style.display = 'none';
            }
        }

        // Cycle through difficulty levels
        async function cycleDifficulty(index) {
            const item = vocabulary[index];
            if (!item) {
                console.error('No vocabulary item at index:', index);
                return;
            }
            
            console.log(`Cycling difficulty for item:`, item);
            
            const difficulties = ['easy', 'medium', 'hard'];
            const currentDiff = item.difficulty || 'medium';
            const currentIndex = difficulties.indexOf(currentDiff);
            const nextIndex = (currentIndex + 1) % difficulties.length;
            
            item.difficulty = difficulties[nextIndex];
            console.log(`Changed difficulty from ${currentDiff} to ${item.difficulty}`);
            
            // Update database if user is authenticated
            if (currentUser && item.id) {
                console.log(`User authenticated (${currentUser.id}), updating database for word ID: ${item.id}`);
                await updateVocabularyDifficulty(item.id, item.difficulty);
                console.log(`Updated difficulty for "${item.urdu}" to ${item.difficulty}`);
            } else {
                console.log(`Not updating database - currentUser: ${!!currentUser}, item.id: ${item.id}`);
                // Fallback to localStorage for anonymous users
                localStorage.setItem('vocabulary', JSON.stringify(vocabulary));
                console.log('Saved to localStorage instead');
            }
            
            // Re-render both mobile and desktop
            renderMobileVocabulary();
            updateVocabulary();
        }

        // Confirm before clearing all vocabulary
        function confirmClearVocab() {
            const totalWords = vocabulary.length;
            if (totalWords === 0) {
                alert('No vocabulary to clear!');
                return;
            }
            
            const firstConfirm = confirm(`‚ö†Ô∏è Delete all ${totalWords} saved words?\n\nThis action cannot be undone.`);
            if (firstConfirm) {
                const secondConfirm = confirm(`üóëÔ∏è Are you absolutely sure?\n\nThis will permanently delete all your vocabulary progress.`);
                if (secondConfirm) {
                    vocabulary = [];
                    localStorage.removeItem('vocabulary');
                    renderMobileVocabulary();
                    updateVocabulary(); // Update desktop sidebar too
                    alert('‚úÖ All vocabulary cleared.');
                }
            }
        }

        // Go to word in text using precise character position
        function goToWord(targetWord, buttonElement) {
            console.log(`Looking for word: "${targetWord}"`);
            
            // Find vocabulary item with precise location data
            const vocabItem = vocabulary.find(item => item.urdu === targetWord);
            
            if (vocabItem && vocabItem.story_index !== undefined && vocabItem.character_position !== undefined) {
                console.log(`Found precise location for "${targetWord}":`, vocabItem);
                goToPreciseLocation(vocabItem, buttonElement);
                return;
            }
            
            console.log(`No precise location data, using fallback search for "${targetWord}"`);
            goToWordOriginal(targetWord, buttonElement);
        }
        
        // Navigate to precise stored location
        function goToPreciseLocation(vocabItem, buttonElement) {
            const targetStoryIndex = vocabItem.story_index;
            const targetPosition = vocabItem.character_position;
            const currentStoryIndex = parseInt(document.getElementById('storySelect').value);
            
            console.log(`Navigating to story ${targetStoryIndex}, position ${targetPosition}`);
            
            if (currentStoryIndex !== targetStoryIndex) {
                // Switch to correct story first
                if (confirm(`Word "${vocabItem.urdu}" is in story ${targetStoryIndex + 1}. Go there now?`)) {
                    hideMobileVocab();
                    document.getElementById('storySelect').value = targetStoryIndex;
                    loadStory(targetStoryIndex);
                    
                    // Navigate to precise position after story loads
                    setTimeout(() => {
                        highlightWordAtPosition(vocabItem.urdu, targetPosition, targetStoryIndex);
                    }, 500);
                }
            } else {
                // Already in correct story, find precise position
                hideMobileVocab();
                highlightWordAtPosition(vocabItem.urdu, targetPosition, targetStoryIndex);
            }
        }
        
        // Highlight word at specific character position
        function highlightWordAtPosition(targetWord, position, storyIndex) {
            console.log(`Highlighting "${targetWord}" at position ${position} in story ${storyIndex}`);
            
            // For now, use the original highlighting method
            // TODO: Calculate exact page from character position
            setTimeout(() => {
                const words = document.querySelectorAll('.urdu-word');
                let found = false;
                
                words.forEach(word => {
                    if (word.textContent.trim() === targetWord) {
                        // Scroll to word
                        word.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        
                        // Highlight word with green background (precise location indicator)
                        word.style.background = '#22c55e';
                        word.style.color = 'white';
                        word.style.fontWeight = 'bold';
                        word.style.border = '2px solid #16a34a';
                        
                        // Remove highlight after 4 seconds
                        setTimeout(() => {
                            word.style.background = '';
                            word.style.color = '';
                            word.style.fontWeight = '';
                            word.style.border = '';
                        }, 4000);
                        
                        found = true;
                        console.log(`Successfully highlighted "${targetWord}" at precise location`);
                        return;
                    }
                });
                
                if (!found) {
                    console.log(`Could not find "${targetWord}" - using fallback`);
                    alert('Word saved from different location. Using search...');
                }
            }, 100);
        }
        
        // Original go to word function (fallback)
        function goToWordOriginal(targetWord, buttonElement) {
            // First check if word exists in current story
            const currentStoryIndex = parseInt(document.getElementById('storySelect').value);
            const currentStory = stories[currentStoryIndex] || '';
            
            if (currentStory.includes(targetWord)) {
                // Word is in current story - highlight it
                hideMobileVocab();
                
                // Find and highlight the word
                setTimeout(() => {
                    const words = document.querySelectorAll('.urdu-word');
                    let found = false;
                    
                    words.forEach(word => {
                        if (word.textContent.trim() === targetWord) {
                            word.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            word.style.background = '#fbbf24';
                            word.style.color = '#1f2937';
                            
                            // Reset highlight after 3 seconds
                            setTimeout(() => {
                                word.style.background = '';
                                word.style.color = '';
                            }, 3000);
                            
                            found = true;
                        }
                    });
                    
                    if (!found) {
                        alert('Word not found in current view. Try navigating to different pages.');
                    }
                }, 100);
            } else {
                // Word not in current story - search other stories
                let foundInStory = -1;
                for (let i = 0; i < stories.length; i++) {
                    if (stories[i].includes(targetWord)) {
                        foundInStory = i;
                        break;
                    }
                }
                
                if (foundInStory !== -1) {
                    if (confirm(`Word "${targetWord}" is in story ${foundInStory + 1}. Go there now?`)) {
                        hideMobileVocab();
                        document.getElementById('storySelect').value = foundInStory;
                        loadStory(foundInStory);
                        
                        // Highlight after story loads
                        setTimeout(() => goToWord(targetWord, null), 500);
                    }
                } else {
                    alert(`Word "${targetWord}" not found in any story. It may have been from a BBC article.`);
                }
            }
        }

        // Save word with precise location context
        async function saveWord(urdu, english) {
            if (vocabulary.some(item => item.urdu === urdu)) {
                alert('Already saved!');
                return;
            }
            
            // Calculate character position for precise "Go to" functionality
            const locationContext = calculateWordPosition(urdu);
            
            // Use database if authenticated, otherwise localStorage
            await saveVocabularyToDatabase(urdu, english, 'medium', locationContext);
            updateVocabBadge(); // Update mobile badge count
        }
        
        // Calculate exact character position and context for saved word
        function calculateWordPosition(targetWord) {
            const storyIndex = parseInt(document.getElementById('storySelect').value);
            const currentStoryText = stories[storyIndex] || '';
            const currentPageText = pagesPerStory[storyIndex] ? pagesPerStory[storyIndex][currentPage] : '';
            
            console.log(`Calculating position for "${targetWord}" in story ${storyIndex}, page ${currentPage}`);
            
            // Find where current page starts in full story
            let pageStartPosition = 0;
            if (pagesPerStory[storyIndex]) {
                for (let i = 0; i < currentPage; i++) {
                    pageStartPosition += pagesPerStory[storyIndex][i].length;
                }
            }
            
            // Find word position within current page
            const wordPositionInPage = currentPageText.indexOf(targetWord);
            
            // Calculate absolute character position in full story
            const absolutePosition = pageStartPosition + wordPositionInPage;
            
            // Create context snippet (50 chars before and after)
            const contextStart = Math.max(0, absolutePosition - 50);
            const contextEnd = Math.min(currentStoryText.length, absolutePosition + targetWord.length + 50);
            const contextSnippet = currentStoryText.substring(contextStart, contextEnd);
            
            console.log(`Word position: page ${wordPositionInPage}, absolute ${absolutePosition}`);
            console.log(`Context: "${contextSnippet}"`);
            
            return {
                story_index: storyIndex,
                character_position: absolutePosition,
                saved_from_context: contextSnippet
            };
        }

        // Check which story contains a word
        function findStoryForWord(targetWord) {
            const currentStoryIndex = parseInt(document.getElementById('storySelect').value);
            
            // Check current story first
            const currentWords = stories[currentStoryIndex].split(' ');
            const foundInCurrent = currentWords.some(word => {
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                return cleanWord === targetWord || 
                       targetWord.includes(cleanWord) || 
                       cleanWord.includes(targetWord);
            });
            
            if (foundInCurrent) {
                return { found: true, isCurrent: true, storyIndex: currentStoryIndex, storyName: document.getElementById('storySelect').options[currentStoryIndex].text };
            }
            
            // Check other stories
            for (let i = 0; i < stories.length; i++) {
                if (i !== currentStoryIndex) {
                    const words = stories[i].split(' ');
                    const foundInStory = words.some(word => {
                        const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                        return cleanWord === targetWord || 
                               targetWord.includes(cleanWord) || 
                               cleanWord.includes(targetWord);
                    });
                    
                    if (foundInStory) {
                        return { found: true, isCurrent: false, storyIndex: i, storyName: document.getElementById('storySelect').options[i].text };
                    }
                }
            }
            
            return { found: false };
        }

        // Update vocabulary display
        function updateVocabulary() {
            const list = document.getElementById('vocabList');
            const clearBtn = document.getElementById('clearButton');
            
            if (vocabulary.length === 0) {
                list.innerHTML = '<div class="empty-vocab">No saved words yet</div>';
                clearBtn.style.display = 'none';
            } else {
                clearBtn.style.display = 'block';
                list.innerHTML = vocabulary.map((item, index) => {
                    const storyInfo = findStoryForWord(item.urdu);
                    let tooltipText;
                    
                    if (!storyInfo.found) {
                        tooltipText = `"${item.urdu}" not found in any story`;
                    } else if (storyInfo.isCurrent) {
                        tooltipText = `Go to "${item.urdu}" in current story`;
                    } else {
                        tooltipText = `Go to "${item.urdu}" in "${storyInfo.storyName}"`;
                    }
                    
                    const difficulty = item.difficulty || 'medium'; // Default for old words
                    return `
                        <div class="vocab-item">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span class="difficulty-dot difficulty-${difficulty}" onclick="cycleDifficulty(${index})" title="Click to change difficulty"></span>
                                <div>
                                    <div class="vocab-word">${item.urdu}</div>
                                    <div class="vocab-translation">${item.english}</div>
                                </div>
                            </div>
                            <div class="vocab-actions">
                                <div class="tooltip">
                                    <button class="jump-button" onclick="goToWord('${item.urdu.replace(/'/g, "\\'")}')">
                                        Go to
                                    </button>
                                    <span class="tooltiptext">${tooltipText}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
            }
            
            // Update saved word indicators in the story
            updateSavedWordIndicators();
        }

        // Update saved word indicators
        function updateSavedWordIndicators() {
            const words = document.querySelectorAll('.urdu-word');
            words.forEach(wordElement => {
                const word = wordElement.textContent;
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                const isSaved = vocabulary.some(item => 
                    item.urdu === cleanWord || 
                    item.urdu.includes(cleanWord) ||
                    cleanWord.includes(item.urdu)
                );
                
                if (isSaved) {
                    wordElement.classList.add('saved');
                } else {
                    wordElement.classList.remove('saved');
                }
            });
        }

        // Jump to word in story
        function jumpToWord(targetWord) {
            // First check if word exists in current story
            const currentWords = document.querySelectorAll('.urdu-word');
            let foundInCurrent = false;
            
            currentWords.forEach(wordElement => {
                const word = wordElement.textContent;
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                
                if (cleanWord === targetWord || 
                    targetWord.includes(cleanWord) || 
                    cleanWord.includes(targetWord)) {
                    foundInCurrent = true;
                }
            });
            
            if (foundInCurrent) {
                // Word found in current story, just highlight it
                highlightWordInCurrentStory(targetWord);
            } else {
                // Word not found, search other stories
                findWordInOtherStories(targetWord);
            }
        }

        // Highlight word in current story
        function highlightWordInCurrentStory(targetWord) {
            const words = document.querySelectorAll('.urdu-word');
            
            words.forEach(wordElement => {
                const word = wordElement.textContent;
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                
                if (cleanWord === targetWord || 
                    targetWord.includes(cleanWord) || 
                    cleanWord.includes(targetWord)) {
                    
                    // Clear previous highlights
                    words.forEach(w => w.classList.remove('active', 'selected'));
                    
                    // Highlight the found word
                    wordElement.classList.add('active');
                    
                    // Scroll to the word
                    wordElement.scrollIntoView({
                        behavior: 'smooth',
                        block: 'center'
                    });
                    
                    // Flash effect
                    wordElement.style.animation = 'flash 1s ease-in-out';
                    setTimeout(() => {
                        wordElement.style.animation = '';
                    }, 1000);
                    
                    return;
                }
            });
        }

        // Find word in other stories
        function findWordInOtherStories(targetWord) {
            let foundStoryIndex = -1;
            
            // Search through all stories
            stories.forEach((story, index) => {
                if (foundStoryIndex === -1) {
                    const words = story.split(' ');
                    words.forEach(word => {
                        const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                        if (cleanWord === targetWord || 
                            targetWord.includes(cleanWord) || 
                            cleanWord.includes(targetWord)) {
                            foundStoryIndex = index;
                        }
                    });
                }
            });
            
            if (foundStoryIndex !== -1) {
                // Get story names from the select options
                const storySelect = document.getElementById('storySelect');
                const storyName = storySelect.options[foundStoryIndex].text;
                
                const confirmMessage = `"${targetWord}" was found in "${storyName}". Switch to that story?`;
                
                if (confirm(confirmMessage)) {
                    // Switch to the story
                    storySelect.value = foundStoryIndex;
                    loadStory(foundStoryIndex);
                    
                    // Wait for story to load, then highlight the word
                    setTimeout(() => {
                        highlightWordInCurrentStory(targetWord);
                    }, 100);
                }
            } else {
                alert(`"${targetWord}" not found in any story.`);
            }
        }

        // Clear vocabulary
        function clearVocabulary() {
            if (confirm('Clear all vocabulary?')) {
                vocabulary = [];
                updateVocabulary();
            }
        }

        // Initialize
        initializePages();
        loadStory(0);
        
        // Initialize authentication UI immediately
        initAuthUI();
        
        // Initialize authentication
        initAuth();
        
        // Load BBC article on startup
        loadBBCArticle();
        
        // Load novel episodes on startup
        loadNovelEpisodes();
        
        // Load novel episodes from external files (PROPER ARCHITECTURE)
        let novelEpisodesLoaded = false; // Prevent duplicate loading
        
        async function loadNovelEpisodes() {
            if (novelEpisodesLoaded) {
                console.log('Novel episodes already loaded, skipping duplicate call');
                return;
            }
            
            console.log('Loading novel episodes from external files...');
            novelEpisodesLoaded = true; // Mark as loading to prevent duplicates
            
            try {
                // Load Episode 1 from external file
                await loadNovelEpisode(1);
                
                // Future episodes can be loaded similarly:
                // await loadNovelEpisode(2);
                // await loadNovelEpisode(3);
                
            } catch (error) {
                console.error('Error loading novel episodes:', error);
                // Fallback: add minimal placeholder if file loading fails
                await addPlaceholderEpisode();
            }
        }
        
        // Load a specific novel episode from external file
        async function loadNovelEpisode(episodeNumber) {
            console.log(`Loading Episode ${episodeNumber} from external file...`);
            
            try {
                const response = await fetch(`/mkm-chapters/ep${episodeNumber}.txt`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: Episode ${episodeNumber} file not found`);
                }
                
                const episodeContent = await response.text();
                
                if (!episodeContent.trim()) {
                    throw new Error(`Episode ${episodeNumber} file is empty`);
                }
                
                // Add to stories array
                stories.push(episodeContent);
                
                // Add to dropdown
                const storySelect = document.getElementById('storySelect');
                const option = document.createElement('option');
                option.value = stories.length - 1;
                option.textContent = `${stories.length}. Mann Kay Muhallay Mein - Episode ${episodeNumber} ‚Ä¢ ŸÖŸÜ ⁄©€í ŸÖÿ≠ŸÑ€í ŸÖ€å⁄∫`;
                option.style.backgroundColor = '#e8f5e8'; // Light green background for novel
                storySelect.appendChild(option);
                
                // Re-initialize pages to include new story
                initializePages();
                
                console.log(`‚úÖ Successfully loaded Episode ${episodeNumber} from external file (${episodeContent.length} characters)`);
                
                return true;
                
            } catch (error) {
                console.error(`‚ùå Failed to load Episode ${episodeNumber}:`, error);
                throw error;
            }
        }
        
        // Fallback function if external file loading fails
        async function addPlaceholderEpisode() {
            console.log('Adding placeholder episode due to loading failure...');
            
            const placeholderContent = `ŸÇÿ≥ÿ∑ ŸÜŸÖÿ®ÿ±1 - ŸÖŸÜ ⁄©€í ŸÖÿ≠ŸÑ€í ŸÖ€å⁄∫ - ÿ¥⁄©€åŸÑ ÿßÿ≠ŸÖÿØ ⁄ÜŸà€ÅÿßŸÜ

‚ö†Ô∏è Episode content loading failed

€å€Å ÿµÿ±ŸÅ ÿß€å⁄© placeholder €Å€í€î ÿßÿµŸÑ content external file ÿ≥€í load ŸÜ€Å€å⁄∫ €ÅŸà ÿ≥⁄©ÿß€î

Technical Error: Unable to fetch episode content from /mkm-chapters/ep1.txt

Please check:
1. File exists at correct location
2. Server is running properly
3. File permissions are correct`;
            
            // Add to stories array
            stories.push(placeholderContent);
            
            // Add to dropdown
            const storySelect = document.getElementById('storySelect');
            const option = document.createElement('option');
            option.value = stories.length - 1;
            option.textContent = `${stories.length}. Mann Kay Muhallay Mein - Episode 1 (Error) ‚Ä¢ ŸÖŸÜ ⁄©€í ŸÖÿ≠ŸÑ€í ŸÖ€å⁄∫`;
            option.style.backgroundColor = '#ffe8e8'; // Light red background for error
            storySelect.appendChild(option);
            
            // Re-initialize pages to include new story
            initializePages();
            
            console.log('Added placeholder episode due to loading failure');
        }
        
        // Function to scrape actual novel content (for future use)
        async function scrapeNovelEpisode(episodeNumber) {
            const episode = novelData.episodes[episodeNumber - 1];
            if (!episode) {
                console.error('Episode not found:', episodeNumber);
                return;
            }
            
            const url = `${novelData.baseUrl}${episode.id}/episode-${episodeNumber}.html`;
            console.log('Would scrape from:', url);
            
            // Note: Actual scraping would require backend/proxy due to CORS
            // For now, return placeholder
            return `€å€Å ÿß€åŸæ€åÿ≥Ÿà⁄à ${episodeNumber} ⁄©ÿß ŸÖÿ™ŸÜ €Å€í€î €å€Åÿß⁄∫ ÿßÿµŸÑ ⁄©€ÅÿßŸÜ€å ⁄©ÿß ŸÖÿ™ŸÜ €ÅŸà⁄Øÿß€î`;
        }
        
        // Novel progress tracking functions
        function saveNovelProgress() {
            localStorage.setItem('novelProgress', JSON.stringify(novelProgress));
        }
        
        function markEpisodeAsRead(episodeNumber) {
            if (!novelProgress.episodesRead.includes(episodeNumber)) {
                novelProgress.episodesRead.push(episodeNumber);
                novelProgress.currentEpisode = Math.max(novelProgress.currentEpisode, episodeNumber + 1);
                saveNovelProgress();
                updateNovelProgressUI();
            }
        }
        
        function updateNovelProgressUI() {
            // Update progress indicators in the UI
            const progress = Math.round((novelProgress.episodesRead.length / novelData.totalEpisodes) * 100);
            console.log(`Novel progress: ${progress}% (${novelProgress.episodesRead.length}/${novelData.totalEpisodes} episodes)`);
            
            // Update progress bar
            const progressFill = document.getElementById('progressFill');
            const progressPercent = document.getElementById('progressPercent');
            const novelProgressDiv = document.getElementById('novelProgress');
            
            if (progressFill && progressPercent) {
                progressFill.style.width = `${progress}%`;
                progressPercent.textContent = `${progress}%`;
                
                // Show progress bar if there's any progress
                if (novelProgress.episodesRead.length > 0 && novelProgressDiv) {
                    novelProgressDiv.style.display = 'flex';
                }
            }
        }
        
        // Check if current story is a novel episode and mark as read
        function checkAndMarkNovelEpisode(storyIndex) {
            // Novel episodes start after the original 4 stories + BBC articles
            if (storyIndex >= 4) {
                const episodeNumber = storyIndex - 3; // Adjust for BBC articles
                if (episodeNumber <= novelData.totalEpisodes) {
                    markEpisodeAsRead(episodeNumber);
                }
            }
        }
        
        // Load novel episodes on startup
        loadNovelEpisodes();
        
        // Initialize mobile vocabulary badge
        updateVocabBadge();
        
        // Add global mouse up event listener for drag selection
        document.addEventListener('mouseup', handleMouseUp);
        
        // Add click listener to hide mobile translation and clear highlights when clicking elsewhere
        document.addEventListener('click', function(e) {
            const mobileBar = document.getElementById('mobileTranslationBar');
            const isMobileBar = e.target.closest('#mobileTranslationBar');
            const isUrduWord = e.target.classList.contains('urdu-word');
            
            if (!isMobileBar && !isUrduWord) {
                // Hide mobile translation bar if showing
                if (mobileBar.classList.contains('show')) {
                    hideMobileTranslation();
                }
                
                // Clear all word highlights
                clearWordHighlights();
                selectedWords = [];
                isSelecting = false;
            }
        });
        
        // Function to clear all word highlights
        function clearWordHighlights() {
            document.querySelectorAll('.urdu-word').forEach(word => {
                word.classList.remove('active', 'selected');
            });
            selectedWords = [];
            isSelecting = false;
        }
        
        // Touch event handlers for mobile multi-word selection
        let touchStartTime = 0;
        let lastTouchTarget = null;
        let touchStartX = 0;
        let touchStartY = 0;
        let hasMovedSignificantly = false;
        let selectionIntentDetected = false;
        
        function handleTouchStart(word, index, event) {
            // Don't prevent default initially - allow natural scrolling
            touchStartTime = Date.now();
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            lastTouchTarget = event.target;
            hasMovedSignificantly = false;
            selectionIntentDetected = false;
            
            // Check if this word is already selected/highlighted
            if (event.target.classList.contains('selected') || event.target.classList.contains('active')) {
                // Toggle off - unhighlight and hide popup
                event.preventDefault(); // Prevent scroll only for this action
                event.target.classList.remove('active', 'selected');
                selectedWords = [];
                isSelecting = false;
                hideMobileTranslation();
                return;
            }
            
            // Store initial selection data but don't start selecting yet
            selectionStart = index;
        }
        
        function handleTouchMove(index, event) {
            const touch = event.touches[0];
            const deltaX = Math.abs(touch.clientX - touchStartX);
            const deltaY = Math.abs(touch.clientY - touchStartY);
            const totalMovement = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            // Check if user has moved significantly (more than 15px)
            if (totalMovement > 15) {
                hasMovedSignificantly = true;
                
                // If vertical movement is dominant, allow scrolling
                if (deltaY > deltaX * 1.5) {
                    // This is likely a scroll gesture - don't interfere
                    isSelecting = false;
                    return;
                }
            }
            
            // If we're already selecting, handle multi-word selection
            if (isSelecting) {
                event.preventDefault(); // Prevent scrolling only when actively selecting
                
                // Find the element under the touch point
                const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
                
                if (elementBelow && elementBelow.classList.contains('urdu-word')) {
                    const currentIndex = parseInt(elementBelow.getAttribute('data-word-index'));
                    
                    // Clear current selection
                    document.querySelectorAll('.urdu-word').forEach(w => w.classList.remove('selected'));
                    
                    // Select range from start to current
                    const start = Math.min(selectionStart, currentIndex);
                    const end = Math.max(selectionStart, currentIndex);
                    
                    selectedWords = [];
                    const words = document.querySelectorAll('.urdu-word');
                    
                    for (let i = start; i <= end; i++) {
                        selectedWords.push(i);
                        words[i].classList.add('selected');
                    }
                    
                    // Update UI to show selection count
                    if (selectedWords.length > 1) {
                        updateSelectionUI();
                    }
                }
            } else if (!hasMovedSignificantly || (deltaX > deltaY && totalMovement > 30)) {
                // Horizontal movement or small movement - could be word selection intent
                // Only start selection if touch duration > 200ms or horizontal drag > 30px
                const touchDuration = Date.now() - touchStartTime;
                if (touchDuration > 200 || (deltaX > deltaY && totalMovement > 30)) {
                    event.preventDefault(); // Now prevent scrolling
                    selectionIntentDetected = true;
                    
                    // Clear previous selections
                    document.querySelectorAll('.urdu-word').forEach(w => {
                        w.classList.remove('active');
                        w.classList.remove('selected');
                    });
                    
                    // Start new selection
                    selectedWords = [selectionStart];
                    lastTouchTarget.classList.add('selected');
                    isSelecting = true;
                }
            }
        }
        
        async function handleTouchEnd(event) {
            const touchDuration = Date.now() - touchStartTime;
            
            // If we were selecting, handle translation
            if (isSelecting && selectedWords.length > 1) {
                // Multi-word selection - translate phrase
                translateSelectedWords();
            } else if (isSelecting && selectedWords.length === 1) {
                // Single word selection - translate immediately
                const index = selectedWords[0];
                const words = document.querySelectorAll('.urdu-word');
                const word = words[index].textContent;
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                
                try {
                    // Check cache
                    if (translationCache.has(cleanWord)) {
                        showTranslation(cleanWord, translationCache.get(cleanWord), words[index]);
                        return;
                    }
                    
                    document.getElementById('translationContent').innerHTML = 'Translating...';
                    const translation = await translateText(cleanWord);
                    translationCache.set(cleanWord, translation);
                    showTranslation(cleanWord, translation, words[index]);
                } catch (error) {
                    showTranslation(cleanWord, 'Translation error', words[index]);
                }
            } else if (!isSelecting && !hasMovedSignificantly && touchDuration < 300) {
                // Quick tap without movement - translate single word
                const word = lastTouchTarget.textContent;
                const cleanWord = word.replace(/[€îÿåÿü!]/g, '');
                const index = parseInt(lastTouchTarget.getAttribute('data-word-index'));
                
                // Clear previous selections and highlight this word
                document.querySelectorAll('.urdu-word').forEach(w => {
                    w.classList.remove('active', 'selected');
                });
                lastTouchTarget.classList.add('selected');
                selectedWords = [index];
                
                try {
                    // Check cache
                    if (translationCache.has(cleanWord)) {
                        showTranslation(cleanWord, translationCache.get(cleanWord), lastTouchTarget);
                        return;
                    }
                    
                    document.getElementById('translationContent').innerHTML = 'Translating...';
                    const translation = await translateText(cleanWord);
                    translationCache.set(cleanWord, translation);
                    showTranslation(cleanWord, translation, lastTouchTarget);
                } catch (error) {
                    showTranslation(cleanWord, 'Translation error', lastTouchTarget);
                }
            }
            
            // Reset state
            isSelecting = false;
            hasMovedSignificantly = false;
            selectionIntentDetected = false;
        }
    </script>
</body>
</html>